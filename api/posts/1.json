{"total":2,"pageSize":10,"pageCount":1,"data":[{"title":"","slug":"【ts】","date":"2025-01-19T11:50:13.178Z","updated":"2025-01-19T11:49:42.787Z","comments":true,"path":"api/articles/【ts】.json","excerpt":"","keywords":null,"cover":null,"content":"<p>TypeScript (简称 TS) 和 JavaScript (简称 JS) 都是用于编写Web应用程序的语言，它们的区别在于：</p>\n<h1 id=\"1-类型不同\"><a href=\"#1-类型不同\" class=\"headerlink\" title=\"1.类型不同\"></a>1.类型不同</h1><p>JS:一种脚本语言，用于创建动态网页，弱类型，没有静态类型选项</p>\n<p>TS：ts是js的超集，用于解决大项项目的代码复杂性，强类型，支持静态和动态类型；ts包含了js的库和函数，ts上可以写任何的js，调用任何的js库，可以在ts中使用原生js语法</p>\n<h1 id=\"2-数据类型不同\"><a href=\"#2-数据类型不同\" class=\"headerlink\" title=\"2.数据类型不同\"></a>2.数据类型不同</h1><p>TS的数据类型有：布尔值、数字、字符串、数组、 元组（tuple）、枚举(enum)、any、void、<br>null和undefined、never、object ，unknown，</p>\n<blockquote>\n<p>基本数据类型有boolean、number 、string 、 array 、 enum 、any 、void。</p>\n</blockquote>\n<p>定义一个boolean的变量:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var isDone: boolean = false;</span><br></pre></td></tr></table></figure>\n<p>JS与TS中的所有数值都是浮点型，而在TS中定义为“number”型。声明一个number类型的变量：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var isNumber:number=6;</span><br><span class=\"line\">var isfloat:number=6.01;</span><br></pre></td></tr></table></figure>\n<p>使用一对双引号(“)或一对单引号(‘)来表示字符串</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name: string = &quot;bob&quot;;</span><br><span class=\"line\">var family_name: string = &#x27;Green&#x27;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>TypeScript 中<strong>数组</strong>使用“[]”来声明，代码如下:</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> var list: number[] = [1, 2, 3];</span><br><span class=\"line\">var name: string[] = [&quot;阿龙&quot;,&quot;阿猫&quot;,&quot;阿狗&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">// 访问方式 </span><br><span class=\"line\">var list: number[] = [1, 2, 3];</span><br><span class=\"line\">alert(list[0]));</span><br><span class=\"line\"></span><br><span class=\"line\">// 定义任意类型的数组，关键字为Array.</span><br><span class=\"line\">var arr:Array = [1,2,3,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]; // 任意类型数组</span><br><span class=\"line\">alert(arr[1]);</span><br></pre></td></tr></table></figure>\n<h2 id=\"enum\"><a href=\"#enum\" class=\"headerlink\" title=\"enum\"></a>enum</h2><p>ts新加的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Color &#123;</span><br><span class=\"line\">  Red,　　　//枚举元素列表</span><br><span class=\"line\">  Green,</span><br><span class=\"line\">  Blue</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var c: Color = Color.Green;</span><br></pre></td></tr></table></figure>\n<p>假如我们有一个数值，但是我们不知道枚举类型中是否有定义，可以用以下方式来获取，代码如下:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Color &#123;</span><br><span class=\"line\">  Red = 1,</span><br><span class=\"line\">  Green,</span><br><span class=\"line\">  Blue</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var colorName: string = Color[2]; //访问第二个枚举子元素Green</span><br><span class=\"line\">alert(colorName);</span><br><span class=\"line\">colorName = Color[4];</span><br><span class=\"line\">alert(colorName);</span><br></pre></td></tr></table></figure>\n<p>那么将会输出Green和undefined。因为Green的值是 2，而没有一个枚举定义的值是 4，所以返回undefined。</p>\n<h2 id=\"任意类型-any\"><a href=\"#任意类型-any\" class=\"headerlink\" title=\"任意类型 any\"></a>任意类型 any</h2><p>和js一样，指代是动态的，能够赋予任意类型</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var notSure: any = 4;</span><br><span class=\"line\">notSure = &quot;maybe a string instead&quot;;</span><br><span class=\"line\">notSure = false;  // 定义为boolen型</span><br></pre></td></tr></table></figure>\n<p>any可以配合数组来使用，代码如下:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var list: any[] = [1, true, &quot;free&quot;];</span><br><span class=\"line\">list[1] = 100; //更改list[1]的值</span><br></pre></td></tr></table></figure>\n<p>注意，不要滥用 any，如果任何值都指定为 any 类型，那么ts将失去它的意义</p>\n<h2 id=\"void\"><a href=\"#void\" class=\"headerlink\" title=\"void\"></a>void</h2><p>void 和 any 相反，any 是表示任意类型，而 void 是表示没有任意类型，就是什么类型都不是，这在我们定义函数，函数没有返回值时会用到：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const consoleText = (text: string): void =&gt; &#123;</span><br><span class=\"line\">  console.log(text);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>void 类型的变量只能赋值为 undefined 和 null，其他类型不能赋值给 void 类型的变量。</p>\n<h2 id=\"never\"><a href=\"#never\" class=\"headerlink\" title=\"never\"></a>never</h2><p>never 类型指那些永不存在的值的类型，它是那些总会抛出异常或根本不会有返回值的函数表达式的返回值类型，当变量被永不为真的类型保护所约束时，该变量也是 never 类型。<br>例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const errorFunc = (message: string): never =&gt; &#123;</span><br><span class=\"line\">  throw new Error(message);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这个 errorFunc 函数总是会抛出异常，所以它的返回值类型是 never，用来表明它的返回值是永不存在的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const infiniteFunc = (): never =&gt; &#123;</span><br><span class=\"line\">  while (true) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<ul>\n<li><p>never：never 是其它类型（包括 null 和 undefined）的子类型，代表从不会出现的值；<br>​</p>\n<blockquote>\n<p>any 和unknown的区别<br>相同： 都可以赋任意类型的值，最终该变量的类型 由最后一个值的类型决定<br>不同： any可以赋值给任意类型的变量，并将该变量的类型修改为any变量值的类型<br>    unknown 不可以<br>    可以把unknown 看做是安全的any</p>\n</blockquote>\n<pre><code>如果非要把unknown 赋值给其他类型 怎么办？\n  使用类型断言、或类型判断（通过if typeof ）\n  类型断言： 变量 as 类型 表示 告诉ts 该变量的实际类型\n</code></pre>\n</li>\n</ul>\n<p>JS的数据类型有：string,number,boolean,null,undefined,object,array,function,symbol(es6中引入)</p>\n<h1 id=\"3-类型声明\"><a href=\"#3-类型声明\" class=\"headerlink\" title=\"3.类型声明\"></a>3.类型声明</h1><p>TS中的类型声明：指定类型后，当变量赋值时，TS编译器就会自动检查值是否符合声明类型，如果符合就赋值，不符合就报错</p>\n<p>JS中的类型声明：变量类型声明并不是强制性的，因为 JavaScript 是一种动态类型语言，变量的类型会在运行时自动确定</p>\n<h1 id=\"4-编译\"><a href=\"#4-编译\" class=\"headerlink\" title=\"4.编译\"></a>4.编译</h1><p>TS需要将代码编译为js代码才能在浏览器中执行</p>\n<p>JS可以直接在浏览器中运行</p>\n<h1 id=\"5-ts的类\"><a href=\"#5-ts的类\" class=\"headerlink\" title=\"5.ts的类\"></a>5.ts的类</h1><h2 id=\"5-1-类的结构\"><a href=\"#5-1-类的结构\" class=\"headerlink\" title=\"5.1 类的结构\"></a>5.1 类的结构</h2><p>创建一个TypeScript类时，必须使用关键字class进行声明，该关键字后紧跟类的名称，之后用大括号将类体进行封装，类的基本声明格式如下。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class 类名&#123;</span><br><span class=\"line\">    //类体</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建完成类的基本结构后就可以编写类体。类体中主要包括属性和方法的声明及定义，当然也可能在类体中只定义属性或只定义方法，甚至类体内可以不定义任何属性。完整的类的定义格式如下。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class 类名&#123;</span><br><span class=\"line\">  name:string;  //定义类的属性</span><br><span class=\"line\">  fun()&#123; //定义类的方法</span><br><span class=\"line\">           //定义该方法所要实现的功能</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>为什么可以不定义任何属性？<br> 类可以被继承，它的方法和属性可以在子类中被继承<br> 未定义任何方法的空类可以作为泛型类<br> 综上未定义任何方法的空类其名称具有价值</li>\n<li>构造函数</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class student&#123;  //定义student类</span><br><span class=\"line\">  name:string;  //定义类的属性</span><br><span class=\"line\">  constructor(myname:string)&#123; //定义构造函数</span><br><span class=\"line\">      this.name=myname;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  study()&#123; //定义类的方法</span><br><span class=\"line\">           //定义该方法所要实现的功能</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-2-类的实例化\"><a href=\"#5-2-类的实例化\" class=\"headerlink\" title=\"5.2 类的实例化\"></a>5.2 类的实例化</h2><p>一般情况下，创建一个类后并不能直接的对属性和方法进行引用，必须对类进行实例化，即创建一个对象。TypeScript中用new 关键字创建对象。实例化后通过“.”来访问属性和方法。实例代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class student&#123;  //定义student类</span><br><span class=\"line\">  name:string;  //定义类的属性</span><br><span class=\"line\">  constructor(myname:string)&#123; //定义带参数的构造函数</span><br><span class=\"line\">      this.name=myname;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">   study()&#123; //定义类的方法</span><br><span class=\"line\">      document.write(&quot;&lt;h1&gt; My name is &quot;+this.name+&quot;.&lt;/h1&gt;&quot;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">   write():string&#123;</span><br><span class=\"line\">           return &quot;write name:&quot;+this.name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>类的使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s1=new student(&quot;Jim&quot;);</span><br><span class=\"line\">document.write(&quot;&lt;h1&gt;&quot;+s1.name+&quot;&lt;/h1&gt;&quot;); //获取name属性</span><br><span class=\"line\">s1.study();   // 调用study方法  </span><br><span class=\"line\">document.write(&quot;&lt;h1&gt;&quot;+s1.write()+&quot;&lt;/h1&gt;&quot;);</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"6-函数的不同：\"><a href=\"#6-函数的不同：\" class=\"headerlink\" title=\"6.函数的不同：\"></a>6.函数的不同：</h1><p>（1）TS：需要对函数中形参进行<strong>类型声明</strong></p>\n<p>JS中函数定义参数，传参的时候，可以传递任意类型，不够严谨</p>\n<p>（2）js中当函数没有返回值的时候 默认返回值是undefined</p>\n<p>TS: 第一种情况：不设置返回值类型，但是有返回值,这个时候TS解析器会根据返回值的类型进行判断，返回值类型是什么 函数返回值类型就是什么</p>\n<p>第二种情况：设置返回值类型，则return的值必须严格按照返回值类型进行返回</p>\n<p>第三种情况：设置返回值类型为void，<br>void:用来表示空，以函数为例，就表示没有返回值的函数,或者说 返回值为空 ，<br>如果想要一点返回值都没有，设置返回值类型为never（永远不会返回结果）</p>\n<h2 id=\"ts函数的定义与调用\"><a href=\"#ts函数的定义与调用\" class=\"headerlink\" title=\"ts函数的定义与调用\"></a>ts函数的定义与调用</h2><p>定义函数的语法为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function function_name(arg:number,arg1:number,....):return_type&#123;</span><br><span class=\"line\">  code 函数要执行的代码;</span><br><span class=\"line\">  return data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>_returntype为该函数的返回值类型</strong> ,function 为声明函数的关键字，function_name 为自定义函数的名字</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function add(x: number, y: number): number &#123;  //定义返回值为number类型的函数</span><br><span class=\"line\">    return x+y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">add(5,6); //调用函数</span><br></pre></td></tr></table></figure>\n<ul>\n<li>匿名函数<br> 匿名函数是没有名称只有主体的函数，不需要指定返回类型，它的返回值类型是从函数主体内的 return 语句推断的。如下代码：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myAdd = function(x:number, y:number) &#123; //定义匿名函数</span><br><span class=\"line\">  return x+y;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">myAdd(3,4); //调用匿名函数</span><br></pre></td></tr></table></figure>\n<ul>\n<li>可选与默认参数<br>可选参数：在参数名后面，冒号前面添加一个问号，则表明该参数是可选的。如下代码：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function buildName(firstName: string, lastName?: string) &#123; //lastName为可选参数</span><br><span class=\"line\">  if (lastName)</span><br><span class=\"line\">      return firstName + &quot; &quot; + lastName;</span><br><span class=\"line\">  else</span><br><span class=\"line\">      return firstName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var result1 = buildName(&quot;Bob&quot;);  //正确调用 Bob</span><br><span class=\"line\">var result2 = buildName(&quot;Bob&quot;, &quot;Adams&quot;); //正确调用 Bob Adams</span><br></pre></td></tr></table></figure>\n<p>默认参数：在参数名后直接给定一个值，如果这个值没有被传入，那么将会被赋值为默认值。如下代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function buildName(firstName: string, lastName = &quot;Smith&quot;) &#123;</span><br><span class=\"line\">  return firstName + &quot; &quot; + lastName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var result1 = buildName(&quot;Bob&quot;);  //没有传入第二个参数，则被赋值为默认的smith,结果为:Bob Smith</span><br><span class=\"line\">var result2 = buildName(&quot;Bob&quot;, &quot;Adams&quot;);  //结果为:Bob Adams</span><br></pre></td></tr></table></figure>\n<p>注：<strong>可选参数和默认参数必须在参数列表的最后。</strong></p>\n<h1 id=\"7-数组类型声明：\"><a href=\"#7-数组类型声明：\" class=\"headerlink\" title=\"7.数组类型声明：\"></a>7.数组类型声明：</h1><p>js中，数组的元素，可以是任意类型，没有局限性</p>\n<p>TS中,对数组类型声明之后就只能存放一种数据类型的数据，假如想创建一个能存储任意类型的数组</p>\n<blockquote>\n<p>let e:Array<any> &#x2F; let e:any[];</p>\n</blockquote>\n<ul>\n<li>第一种：</li>\n</ul>\n<blockquote>\n<p>let 变量名:类型名[];</p>\n</blockquote>\n<ul>\n<li>第二种：</li>\n</ul>\n<blockquote>\n<p>let 变量名:Array&lt;类型名&gt;;</p>\n</blockquote>\n<h1 id=\"8-TS中的枚举和JS中的对象不一样\"><a href=\"#8-TS中的枚举和JS中的对象不一样\" class=\"headerlink\" title=\"8.TS中的枚举和JS中的对象不一样\"></a>8.TS中的枚举和JS中的对象不一样</h1><p>枚举代表的是一系列特定类型的对象 这是从别的编程语言派生出来的概念，所以我们不能用 js 的概念强加到它上面，其实枚举最好理解的就是一系列确定的常量。枚举中的属性，只能用来取值，不能重新赋值 [只读属性]</p>\n<h1 id=\"9-创建对象的方式：\"><a href=\"#9-创建对象的方式：\" class=\"headerlink\" title=\"9.创建对象的方式：\"></a>9.创建对象的方式：</h1><p>JS的创建对象的方式：1.基于Object的方式创建对象，2.对象字面量，3.构造函数，4.原型prototype，5.class 类</p>\n<p>TS的创建对象的方式：1、通过字面量 2、通过0bject 3、通过工厂模式创建 4、通过构造函数创建 5、通过class类创建 6、可以通过实现接口创建 7、通过继承抽象类创建</p>\n<h1 id=\"10-ts接口与类\"><a href=\"#10-ts接口与类\" class=\"headerlink\" title=\"10.ts接口与类\"></a>10.ts接口与类</h1><h2 id=\"10-1-定义和用途\"><a href=\"#10-1-定义和用途\" class=\"headerlink\" title=\"10.1. 定义和用途\"></a>10.1. 定义和用途</h2><ul>\n<li><p>接口：<strong>用于限制对象的具体属性</strong><br>用于定义对象的结构和类型，包括属性和方法的名称及其类型。接口提供了一种协议，确保实现它的对象遵循特定的形态。它不包含任何实现细节。</p>\n</li>\n<li><p>类：用于创建对象的蓝图，包括属性和方法的实现。类可以包含构造函数、访问修饰符（如 public、private）、静态方法等，允许创建对象的实例。</p>\n</li>\n</ul>\n<h2 id=\"10-2-实现\"><a href=\"#10-2-实现\" class=\"headerlink\" title=\"10.2.实现\"></a>10.2.实现</h2><p>接口：接口可以被类实现（使用 implements 关键字），一个类可以实现多个接口，达到多重继承的效果。</p>\n<p>类：类可以继承其他类（使用 extends 关键字），该过程中可以重用父类的实现和属性。但一个类只能继承一个父类，这被称为单继承。</p>\n<h2 id=\"10-3可以包含的内容\"><a href=\"#10-3可以包含的内容\" class=\"headerlink\" title=\"10.3可以包含的内容\"></a>10.3可以包含的内容</h2><ul>\n<li><p>接口：只能定义属性和方法的签名，不能包含具体的实现。接口可以扩展其他接口。</p>\n</li>\n<li><p>类：可以包含完整的方法实现、构造函数、字段、修饰符等。</p>\n</li>\n</ul>\n<h2 id=\"10-4-实例化\"><a href=\"#10-4-实例化\" class=\"headerlink\" title=\"10.4 实例化\"></a>10.4 实例化</h2><blockquote>\n<ul>\n<li>接口：不能被实例化。接口只是定义的一个约束，不能用作对象的实例。</li>\n<li>类：可以被实例化。类可以通过 new 操作符创建对象的实例。</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> // 定义接口  </span><br><span class=\"line\">interface Animal &#123;  </span><br><span class=\"line\">    name: string;  </span><br><span class=\"line\">    sound(): string;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"> </span><br><span class=\"line\">// 实现接口的类  </span><br><span class=\"line\">class Dog implements Animal &#123;  </span><br><span class=\"line\">    name: string;  </span><br><span class=\"line\"> </span><br><span class=\"line\">    constructor(name: string) &#123;  </span><br><span class=\"line\">        this.name = name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"> </span><br><span class=\"line\">    sound(): string &#123;  </span><br><span class=\"line\">        return &quot;Bark&quot;;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"> </span><br><span class=\"line\">// 实例化类  </span><br><span class=\"line\">const myDog = new Dog(&quot;Buddy&quot;);  </span><br><span class=\"line\">console.log(myDog.name); // 输出：Buddy  </span><br><span class=\"line\">console.log(myDog.sound()); // 输出：Bark</span><br></pre></td></tr></table></figure>\n<p>在这个示例中，Animal 是一个接口，定义了 name 属性和 sound 方法。Dog 是一个实现了 Animal 接口的类，具体实现了 sound 方法。最后，我们用 new 关键字创建了 Dog 的实例</p>\n</blockquote>\n<ul>\n<li>接口用来申明方法</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Animal &#123;   // 动物接口</span><br><span class=\"line\">    eat() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Sheep implements Animal &#123; // implements声明sheep类实现Animal接口</span><br><span class=\"line\">    // 当一个类实现一个接口时必须实现接口中声明的方法,否则报错</span><br><span class=\"line\">    eat() &#123;</span><br><span class=\"line\">        console.log(&#x27;sheep实现animal接口&#x27;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>当一个类实现一个接口时必须实现接口中声明的方法</strong></p>\n<h1 id=\"11-泛型\"><a href=\"#11-泛型\" class=\"headerlink\" title=\"11.泛型\"></a>11.泛型</h1><p>JavaScript是一种基于原型的语言，而不是传统的面向对象语言，不支持模块，不支持泛型或接口</p>\n<p>TypeScript在JavaScript的基础上添加了类、接口、继承、泛型等面向对象编程的概念和特性，它允许模块化编程，可以把声明、数据、函数和类封装在模块中。使得代码组织和维护更加容易</p>\n<ul>\n<li>概述：<br>参数化的类型，一般用来限制集合的内容</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var workers: Array&lt;Person&gt; = [];</span><br><span class=\"line\">// 尖括号中的Person类型就是这个数组的泛型，规定了数组中只能放Person类型</span><br><span class=\"line\">workers[0] = new Person(&#x27;zhangsan&#x27;);</span><br><span class=\"line\">workers[1] = new Person(&#x27;lisi&#x27;);  </span><br><span class=\"line\">workers[2] = 1;  // 报错</span><br></pre></td></tr></table></figure>\n<ul>\n<li>模块<br>模块将代码分割成可重用的单元，开发者可以自行决定将模块中的哪些资源（类、方法、变量）暴露出去供外部使用，哪些资源只在模块内部使用。</li>\n</ul>\n<ul>\n<li>export: 对外暴露</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// a.ts</span><br><span class=\"line\">export var prop1;   // 对外暴露prop1属性</span><br><span class=\"line\">var prop2;  // 不对外暴露</span><br><span class=\"line\"></span><br><span class=\"line\">export function func1() &#123;&#125;  // 对外暴露func1方法</span><br><span class=\"line\">function func2() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export class Clazz1 &#123;&#125;</span><br><span class=\"line\">class Clazz2 &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// b.ts</span><br><span class=\"line\">import &#123;prop1, func1&#125; from &#x27;./a&#x27;;</span><br><span class=\"line\">console.log(prop1);</span><br><span class=\"line\">func1();      // 调用a.ts模块中对外暴露的方法</span><br></pre></td></tr></table></figure>\n<h1 id=\"12-ts模块\"><a href=\"#12-ts模块\" class=\"headerlink\" title=\"12.ts模块\"></a>12.ts模块</h1><p>我们先举个例子，比如数据验证，我们需要验证用户数字的内容是否是数字或者字母时，需要使用正则表达式。</p>\n<p>var lettersRegexp &#x3D; &#x2F; ^ [A-Za-z]+$&#x2F;;</p>\n<p>var numberRegexp &#x3D; &#x2F; ^ [0-9]+$&#x2F;;</p>\n<p>使用 module 关键字来定义模块，并在末尾加花括号即可用；<br> 用export 关键字使接口、类等成员对模块外可见。<br> <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> module Validation &#123;   //定义模块</span><br><span class=\"line\">  export interface StringValidator &#123;  //声明接口对外部可以使用</span><br><span class=\"line\">    isAcceptable(s: string): boolean;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  var lettersRegexp = /^[A-Za-z]+$/;</span><br><span class=\"line\">  var numberRegexp = /^[0-9]+$/;</span><br><span class=\"line\"></span><br><span class=\"line\">  export class LettersOnlyValidator implements StringValidator &#123;  //声明类对外部可用</span><br><span class=\"line\">    isAcceptable(s: string) &#123;</span><br><span class=\"line\">      return lettersRegexp.test(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  export class ZipCodeValidator implements StringValidator &#123;</span><br><span class=\"line\">    isAcceptable(s: string) &#123;</span><br><span class=\"line\">      return s.length === 5 &amp;&amp; numberRegexp.test(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"12-1-模块内容的调用\"><a href=\"#12-1-模块内容的调用\" class=\"headerlink\" title=\"12.1 模块内容的调用\"></a>12.1 模块内容的调用</h2><p>在前面一节中我学习了模块的声明，而在模块声明完成以后，我们就可以调用这个模块了，调用模块中的接口、类、方法等。调用方法简单，就是用模块名后面跟一个点来调用类、接口、方法等。如下代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">var strings = [&#x27;Hello&#x27;, &#x27;98052&#x27;, &#x27;101&#x27;];</span><br><span class=\"line\">var validators: &#123; [s: string]: Validation.StringValidator; &#125; = &#123;&#125;;</span><br><span class=\"line\">validators[&#x27;ZIP code&#x27;] = new Validation.ZipCodeValidator();  //使用模块中的类</span><br><span class=\"line\">validators[&#x27;Letters only&#x27;] = new Validation.LettersOnlyValidator();</span><br><span class=\"line\">// 显示匹配结果</span><br><span class=\"line\">for(var i=0;i&amp;ltstrings.length;i++)&#123;</span><br><span class=\"line\">  for (var name in validators) &#123;</span><br><span class=\"line\">     document.write(&#x27;&quot;&#x27; + strings[i] + &#x27;&quot; &#x27; + (validators[name].isAcceptable(strings[i]) ? &#x27; matches &#x27; : &#x27; does not match &#x27;) + name+&quot;&lt;br&gt;&quot;); // 使用方法</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"12-2分隔模块到多个文件\"><a href=\"#12-2分隔模块到多个文件\" class=\"headerlink\" title=\"12.2分隔模块到多个文件\"></a>12.2分隔模块到多个文件</h2><p>随着我们项目的扩展，我们的代码总不可能只写在一个文件里。为了更好地维护项目，我们会将特定功能放到一个文件里，然后加载多个文件实现我们想需要的功能。现在我们先将上面的代码分割到多个文件里。</p>\n<ul>\n<li>文件一    Validation.ts</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module Validation &#123;</span><br><span class=\"line\">  export interface StringValidator &#123;</span><br><span class=\"line\">      isAcceptable(s: string): boolean;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>文件二   LettersOnlyValidator.ts</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;</span><br><span class=\"line\">module Validation &#123;</span><br><span class=\"line\">  var lettersRegexp = /^[A-Za-z]+$/;</span><br><span class=\"line\">  export class LettersOnlyValidator implements StringValidator &#123;</span><br><span class=\"line\">      isAcceptable(s: string) &#123;</span><br><span class=\"line\">        return lettersRegexp.test(s);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>文件三    ZipCodeValidator.ts</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;</span><br><span class=\"line\">module Validation &#123;</span><br><span class=\"line\">  var numberRegexp = /^[0-9]+$/;</span><br><span class=\"line\">  export class ZipCodeValidator implements StringValidator &#123;</span><br><span class=\"line\">    isAcceptable(s: string) &#123;</span><br><span class=\"line\">      return s.length === 5 &amp;&amp; numberRegexp.test(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>文件四 Test.ts</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;</span><br><span class=\"line\">/// &lt;reference path=&quot;LettersOnlyValidator.ts&quot; /&gt;</span><br><span class=\"line\">/// &lt;reference path=&quot;ZipCodeValidator.ts&quot; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">var strings = [&#x27;Hello&#x27;, &#x27;98052&#x27;, &#x27;101&#x27;];</span><br><span class=\"line\">var validators: &#123; [s: string]: Validation.StringValidator; &#125; = &#123;&#125;;</span><br><span class=\"line\">validators[&#x27;ZIP code&#x27;] = new Validation.ZipCodeValidator();</span><br><span class=\"line\">validators[&#x27;Letters only&#x27;] = new Validation.LettersOnlyValidator();</span><br><span class=\"line\">for(var i=0;i&amp;ltstrings.length;i++)&#123;</span><br><span class=\"line\">  for (var name in validators) &#123;</span><br><span class=\"line\">     document.write(&#x27;&quot;&#x27; + strings[i] + &#x27;&quot; &#x27; + (validators[name].isAcceptable(strings[i]) ? &#x27; matches &#x27; : &#x27; does not match &#x27;) + name+&quot;&lt;br&gt;&quot;); //调用类的方法</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在项目中新建好以上四个文件，然后我们编译项目，如果我们代码编写没错的话，是能够编译通过的。</p>\n<blockquote>\n<p>我们可以见到后面三个文件开头的文档注释，</p>\n<blockquote>\n<p>&#x2F;&#x2F;&#x2F; &lt; reference path&#x3D;“Validation.ts” &#x2F;&gt;<br>&#x2F;&#x2F;&#x2F; &lt; reference path&#x3D;“LettersOnlyValidator.ts” &#x2F;&gt;<br>&#x2F;&#x2F;&#x2F; &lt; reference path&#x3D;“ZipCodeValidator.ts” &#x2F;&gt;</p>\n<blockquote>\n<blockquote>\n<p>这是告诉 TypeScript 编译器该文件依赖于哪些文件，假如依赖的文件不存在的话，编译就会不通过。当然我们不写也是可以的，只不过编译器在编译时不会帮我们检查，一般来说，还是建议写上。</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<h2 id=\"12-3-TS的编译\"><a href=\"#12-3-TS的编译\" class=\"headerlink\" title=\"12.3 TS的编译\"></a>12.3 TS的编译</h2><p>我们知道.js的文件可以直接在浏览器中运行的，而.ts或者.tsx却不行，所以我们在运行TS项目时需要编译成浏览器引擎可以识别的JS语言。同时为了提高编译速度，我们可以将稳定的module提前编译成js文件放到工程中，这样下次编译就会直接跳过该nodule的编译。在引用编译生成的 JavaScript 文件时，我们需要注意好顺序。以上面的代码为例，我们在 Html 代码中这么引用。</p>\n<h1 id=\"13-继承\"><a href=\"#13-继承\" class=\"headerlink\" title=\"13.继承\"></a>13.继承</h1><p>TypeScript 支持类的继承，可以通过 extends 关键字指定一个类继承自另一个类。</p>\n<p>而在 JavaScript 中，除了es6，其他的语法规范，不支持使用extends来继承。</p>\n<h1 id=\"13-访问修饰符\"><a href=\"#13-访问修饰符\" class=\"headerlink\" title=\"13.访问修饰符\"></a>13.访问修饰符</h1><p>TypeScript 引入了额外的访问修饰符（如 public、private 和 protected）来控制类的成员的访问范围。这增加了对类及其成员的访问权限控制。而在 JavaScript 中，类和类成员的访问权限是公共的。</p>\n<h1 id=\"14-可选的构造函数参数\"><a href=\"#14-可选的构造函数参数\" class=\"headerlink\" title=\"14.可选的构造函数参数\"></a>14.可选的构造函数参数</h1><p>在 TypeScript 中，我们可以在构造函数参数上使用 ? 表示可选参数。这使得我们可以定义构造函数参数的可选性。而在 JavaScript 中，构造函数参数是必需的。</p>\n<h1 id=\"15-重载\"><a href=\"#15-重载\" class=\"headerlink\" title=\"15.重载\"></a>15.重载</h1><p>js没有重载概念</p>\n<p>ts有可以重载：重载指的是在同一个类中定义多个同名的方法，但它们的参数类型、参数个数或返回类型不同。通过重载，我们可以为同一个方法名创建多个具有不同参数的版本。</p>\n<h1 id=\"16-重写\"><a href=\"#16-重写\" class=\"headerlink\" title=\"16.重写\"></a>16.重写</h1><p>ts增加了重写，子类覆盖了父类中的属性或者是方法叫做重写 子类和父类同名的方法和属性，在子类中重新声明的时候，就覆盖了父类原本的内容）</p>\n<h1 id=\"17-static和readonly\"><a href=\"#17-static和readonly\" class=\"headerlink\" title=\"17.static和readonly\"></a>17.static和readonly</h1><p>ts中增加了static和readonly，而js中没有</p>\n<p>static</p>\n<p>（静态修饰符，被static修饰的属性或者是方法，属于类的。可以通过类名调用，不属于实例的，实例没办使用 和es6中的static一样）</p>\n<p>readonly<br>（被readonly修饰的属性，只能读取不能修改）</p>\n","text":"TypeScript (简称 TS) 和 JavaScript (简称 JS) 都是用于编写Web应用程序的语言，它们的区别在于：1.类型不同JS:一种脚本语言，用于创建动态网页，弱类型，没有静态类型选项TS：ts是js的超集，用于解决大项项目的代码复杂性，强类型，支持静态和动态","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"","slug":"es6","date":"2025-01-15T14:25:29.088Z","updated":"2025-01-15T14:47:45.997Z","comments":true,"path":"api/articles/es6.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"一-入门\"><a href=\"#一-入门\" class=\"headerlink\" title=\"一.入门\"></a>一.入门</h1><ul>\n<li>const和let是在ES6中引入的两个新的变量声明关键字，用于声明变量的作用域.</li>\n</ul>\n<h1 id=\"1-const-let-var\"><a href=\"#1-const-let-var\" class=\"headerlink\" title=\"1.const let var\"></a>1.const let var</h1><h2 id=\"1-1-const：\"><a href=\"#1-1-const：\" class=\"headerlink\" title=\"1.1 const：\"></a>1.1 const：</h2><ol>\n<li></li>\n</ol>\n<p>(1)一定要赋初始值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const A; //error</span><br></pre></td></tr></table></figure>\n<p>(2)一般常量使用大写（潜规则）<br>(3)常量的值不能修改<br>(4)也具有块级作用域</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    const pyaler = &#x27;uzi&#x27;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(player) //error</span><br></pre></td></tr></table></figure>\n<p>(5) 对于数组和对象的元素修改，不算作对常量的修改</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const TEAM = [&#x27;uzi&#x27;,&#x27;MXLG&#x27;,&#x27;Ming&#x27;,&#x27;Letme&#x27;];</span><br><span class=\"line\">TEAM.push(&#x27;Meiko&#x27;); //不报错，常量地址没有发生变化</span><br><span class=\"line\"></span><br><span class=\"line\">TEAM = 100 //error</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-const注意和应用场景\"><a href=\"#2-const注意和应用场景\" class=\"headerlink\" title=\"2.const注意和应用场景\"></a>2.const注意和应用场景</h3><p><strong>注意</strong>: <strong>对象属性修改和数组元素变化不会出发 const 错误</strong></p>\n<p><strong>应用场景</strong>：<strong>声明对象类型使用 const，非对象类型声明选择 let</strong></p>\n<h2 id=\"1-2-let：\"><a href=\"#1-2-let：\" class=\"headerlink\" title=\"1.2  let：\"></a>1.2  let：</h2><p> 1.let用于声明<strong>块级作用域</strong>的<strong>变量</strong>，它与var相比具有更小的作用域范围。在块级作用域内部声明的变量只在该块级作用域内有效，而且不会被提升到函数作用域。例如：<br>  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> function example() &#123;</span><br><span class=\"line\">  let x = 10;</span><br><span class=\"line\">  if (true) &#123;</span><br><span class=\"line\">    let x = 20;</span><br><span class=\"line\">    console.log(x); // 输出 20</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  console.log(x); // 输出 10</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>在使用块级作用域时，可以避免变量之间的命名冲突和问题。</li>\n<li></li>\n</ul>\n<p>2.变量不能重复声明（var可以重复声明）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let star=&#x27;罗志祥&#x27;;</span><br><span class=\"line\">let star=&#x27;小猪&#x27;  //error</span><br><span class=\"line\">//但使用var 重复定义 star 不会报错，因此要使用let，防止变量污染 </span><br></pre></td></tr></table></figure>\n\n<p>3.不存在变量提升<br>4.<strong>应用场景</strong>：<br>以后声明变量使用 let 就对了；<br>块级作用域不仅仅针对花括号，例如if 、else、while、for里面；<br>常用于for</p>\n<h2 id=\"1-3-var：\"><a href=\"#1-3-var：\" class=\"headerlink\" title=\"1.3 var：\"></a>1.3 var：</h2><p>var声明的变量属于<strong>函数作用域或全局作用域</strong>，而不是块级作用域，因此在循环或条件语句中声明的变量会被提升到外部函数作用域。例如：<br>  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  function example() &#123;</span><br><span class=\"line\">  var x = 10;</span><br><span class=\"line\">  if (true) &#123;</span><br><span class=\"line\">    var x = 20;</span><br><span class=\"line\">    console.log(x); // 输出 20</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  console.log(x); // 输出 20，而不是 10</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>var声明的变量存在变量提升的问题，在变量声明之前就可以访问到变量，可能导致意外的结果。</li>\n</ul>\n<h1 id=\"2-变量的解构赋值\"><a href=\"#2-变量的解构赋值\" class=\"headerlink\" title=\"2.变量的解构赋值\"></a>2.变量的解构赋值</h1><p>ES6 允许按照一定模式从数组和对象中提取值，对变量进行赋值，这被称为解构赋值。</p>\n<blockquote>\n<p>数组的解构（不常用）</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const F4 = [&#x27;小沈阳&#x27;，&#x27;刘能&#x27;,&#x27;赵四&#x27;,&#x27;宋小宝&#x27;]</span><br><span class=\"line\">let [xiao,liu,zhao,song] = F4; </span><br><span class=\"line\">console.log(xiao)</span><br><span class=\"line\">console.log(liu)</span><br><span class=\"line\">console.log(zhao)</span><br><span class=\"line\">console.log(song)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>对象的解构（常用）</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const zhao = &#123;</span><br><span class=\"line\">    name : &#x27;赵本山&#x27;，</span><br><span class=\"line\">    age: &#x27;不详&#x27;,</span><br><span class=\"line\">    xiaopin: function()&#123;</span><br><span class=\"line\">        console.log(&quot;我可以演小品&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let &#123;name,age,xiaopin&#125; = zhao;</span><br><span class=\"line\">console.log(name);</span><br><span class=\"line\">console.log(age);</span><br><span class=\"line\">console.log(xiaopin);</span><br><span class=\"line\">xiaopin();</span><br><span class=\"line\"></span><br><span class=\"line\">// 不用以上方法的话，使用xiaopin方法时，需要 zhao.xiaopin()</span><br><span class=\"line\">// 使用以上方法结构，只需要 xiaopin() ,不用带前面的 zhao.</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>复杂结构</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let wangfei = &#123;</span><br><span class=\"line\"> name: &#x27;王菲&#x27;,</span><br><span class=\"line\"> age: 18,</span><br><span class=\"line\"> songs: [&#x27;红豆&#x27;, &#x27;流年&#x27;, &#x27;暧昧&#x27;, &#x27;传奇&#x27;],</span><br><span class=\"line\"> history: [</span><br><span class=\"line\"> &#123;name: &#x27;窦唯&#x27;&#125;,</span><br><span class=\"line\"> &#123;name: &#x27;李亚鹏&#x27;&#125;,</span><br><span class=\"line\"> &#123;name: &#x27;谢霆锋&#x27;&#125;</span><br><span class=\"line\"> ]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">let &#123;songs: [one, two, three], history: [first, second, third]&#125; = </span><br><span class=\"line\">wangfei;</span><br></pre></td></tr></table></figure>\n<p><strong>注意：频繁使用对象方法、数组元素，就可以使用解构赋值形式</strong></p>\n<h1 id=\"3-模板字符串\"><a href=\"#3-模板字符串\" class=\"headerlink\" title=\"3.模板字符串\"></a>3.模板字符串</h1><p>模板字符串（template string）是增强版的字符串，用反引号（&#96;）标识，特点：</p>\n<p>1.字符串中可以出现换行符<br>2.可以使用 ${xxx} 形式输出变量</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 声明</span><br><span class=\"line\">let str = `我也是一个字符串`</span><br><span class=\"line\">console.log(str,typeof str);</span><br><span class=\"line\"></span><br><span class=\"line\">// 特性1：内容中可以直接出现换行符</span><br><span class=\"line\">// 否则之前使用 &quot;&quot;+ 进行拼接</span><br><span class=\"line\">let str = `&lt;ul&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;li&gt;沈腾&lt;/li&gt;</span><br><span class=\"line\">\t\t\t\t\t &lt;li&gt;玛丽&lt;/li&gt;</span><br><span class=\"line\">\t\t\t\t\t &lt;li&gt;魏翔&lt;/li&gt;</span><br><span class=\"line\">\t\t\t\t\t &lt;li&gt;艾伦&lt;/li&gt;</span><br><span class=\"line\">\t\t\t\t\t &lt;/ul&gt;`;</span><br><span class=\"line\"></span><br><span class=\"line\">// 特性2：变量拼接</span><br><span class=\"line\">let lovest = &#x27;魏翔&#x27;;</span><br><span class=\"line\">let out = `$&#123;lovest&#125;在前几年离开了开心麻花`;</span><br><span class=\"line\">console.log(out)</span><br></pre></td></tr></table></figure>\n<p><strong>注意：当遇到字符串与变量拼接的情况使用模板字符串</strong></p>\n<h1 id=\"4-简化对象写法\"><a href=\"#4-简化对象写法\" class=\"headerlink\" title=\"4.简化对象写法\"></a>4.简化对象写法</h1><p>ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p>\n<p>属性名和变量名相同的话，可以进行简化。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name = &#x27;尚硅谷&#x27;;</span><br><span class=\"line\">let slogon = &#x27;永远追求行业更高标准&#x27;;</span><br><span class=\"line\">let improve = function () &#123;</span><br><span class=\"line\"> console.log(&#x27;可以提高你的技能&#x27;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//属性和方法简写</span><br><span class=\"line\">let atguigu = &#123;</span><br><span class=\"line\"> name,   //name:name, 简写成 name</span><br><span class=\"line\"> slogon,  //slogon:slogon, 简写成 slogon</span><br><span class=\"line\"> improve,</span><br><span class=\"line\"> change() &#123;</span><br><span class=\"line\">\t console.log(&#x27;可以改变你&#x27;)</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意：对象简写形式简化了代码，所以以后用简写就对了</strong></p>\n<h1 id=\"5-箭头函数\"><a href=\"#5-箭头函数\" class=\"headerlink\" title=\"5.箭头函数\"></a>5.箭头函数</h1><p>ES6 允许使用「箭头」（&#x3D;&gt;）定义函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"> //1. 通用写法              </span><br><span class=\"line\"></span><br><span class=\"line\">let sum = (a, b) =&gt; a + b;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 这个箭头函数是下面这个函数的更短的版本：</span><br><span class=\"line\"></span><br><span class=\"line\">let sum = function(a, b) &#123;</span><br><span class=\"line\">  return a + b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\">alert( sum(1, 2) ); // 3</span><br></pre></td></tr></table></figure>\n<p>箭头函数对于简单的操作很方便，特别是对于单行的函数。它具体有两种形式：</p>\n<p>1.不带花括号：let 变量名&#x3D;(…args) &#x3D;&gt; expression —— 右侧是一个表达式：函数计算表达式并返回其结果。<br>如果只有一个参数，则可以省略括号，例如 n &#x3D;&gt; n*2。<br>2.带花括号：let 变量名&#x3D;(…args) &#x3D;&gt; { body } —— 花括号允许我们在函数中编写多个语句，但是我们需要<br><strong>显式</strong>地 <strong>return</strong> 来返回一些内容。<br>例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let sum = (a, b) =&gt; &#123;  // 花括号表示开始一个多行函数</span><br><span class=\"line\">  let result = a + b;</span><br><span class=\"line\">  return result; // 如果我们使用了花括号，那么我们需要一个显式的 “return”</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">alert( sum(1, 2) ); // 3</span><br></pre></td></tr></table></figure>\n\n<p>3.简写<br>…(1)如果我们只有一个参数，还可以省略掉参数外的圆括号，使代码更短。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let add = n =&gt; n * 2;</span><br><span class=\"line\">// 等同于：</span><br><span class=\"line\">let add = n =&gt; &#123;</span><br><span class=\"line\">    return n *2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">alert( add(3) ); // 6</span><br></pre></td></tr></table></figure>\n<p>(2)如果没有参数，括号则是空的（<strong>但括号必须保留）</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let sayHi = () =&gt; alert(&quot;Hello!&quot;);</span><br><span class=\"line\">sayHi();</span><br></pre></td></tr></table></figure>\n\n<p>·<br>*通用场景：箭头函数对于简单的单行行为（action）来说非常方便</p>\n<h2 id=\"5-1-特性\"><a href=\"#5-1-特性\" class=\"headerlink\" title=\"5.1 特性\"></a>5.1 特性</h2><p>1.this是静态的，this始终指向函数声明时所在作用域下的this的值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function A()&#123;</span><br><span class=\"line\">    console.log(this.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let B = () =&gt; &#123;</span><br><span class=\"line\">    console.log(this.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">window.name = &#x27;尚硅谷&#x27;;</span><br><span class=\"line\">const school = &#123;</span><br><span class=\"line\">    name: &#x27;ATGUIGU&#x27;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//直接调用</span><br><span class=\"line\">A()   //尚硅谷</span><br><span class=\"line\">B()  //尚硅谷</span><br><span class=\"line\"></span><br><span class=\"line\">//call 改变作用域</span><br><span class=\"line\">A.call(school); //ATGUIGU</span><br><span class=\"line\">B.call(school);  //尚硅谷 箭头函数的this值未改变</span><br></pre></td></tr></table></figure>\n<p>2.不能作为构造实例化对象</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let A = (name,age) =&gt; &#123;</span><br><span class=\"line\">    this.name=name;</span><br><span class=\"line\">    this.age=age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let me = new A(&#x27;xiao&#x27;,123);</span><br><span class=\"line\">console.me //error</span><br></pre></td></tr></table></figure>\n<p>3.不能使用arguments变量<br>（arguments变量是用来保存实参的）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let fn = () =&gt; &#123;</span><br><span class=\"line\">    console.log(arguments)；</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn(1,2,3)  //error</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-2样例\"><a href=\"#5-2样例\" class=\"headerlink\" title=\"5.2样例\"></a>5.2样例</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;箭头函数实践&lt;/title&gt;</span><br><span class=\"line\">    &lt;style&gt;</span><br><span class=\"line\">        div &#123;</span><br><span class=\"line\">            width: 200px;</span><br><span class=\"line\">            height: 200px;</span><br><span class=\"line\">            background: #58a;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=&quot;ad&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        //需求-1  点击 div 2s 后颜色变成『粉色』</span><br><span class=\"line\">        //获取元素</span><br><span class=\"line\">        let ad = document.getElementById(&#x27;ad&#x27;);</span><br><span class=\"line\">\t\t\t\t// 绑定事件</span><br><span class=\"line\">        // 方法1： </span><br><span class=\"line\">        ad.addEventListener(&quot;click&quot;, function()&#123;</span><br><span class=\"line\">            //保存 this 的值</span><br><span class=\"line\">            let _this = this; //将外层的this值进行保存，下面函数里面就可以用了，</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\t否则下面函数的this不同，并没有包含style属性，就会报错</span><br><span class=\"line\">            //定时器</span><br><span class=\"line\">            setTimeout(function()&#123;</span><br><span class=\"line\">                //修改背景颜色 this</span><br><span class=\"line\">                // console.log(this);  </span><br><span class=\"line\">                _this.style.background = &#x27;pink&#x27;;</span><br><span class=\"line\">            &#125;, 2000);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">\t\t\t // 方法2： 使用箭头函数，因为箭头函数是静态的，始终指向创建时的this值 </span><br><span class=\"line\">        ad.addEventListener(&quot;click&quot;, function()&#123;</span><br><span class=\"line\">            setTimeout(() =&gt; &#123;</span><br><span class=\"line\">                //修改背景颜色 this</span><br><span class=\"line\">                this.style.background = &#x27;pink&#x27;;</span><br><span class=\"line\">            &#125;, 2000);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        //需求-2  从数组中返回偶数的元素</span><br><span class=\"line\">        const arr = [1,6,9,10,100,25];</span><br><span class=\"line\">\t\t\t\t//方法1：</span><br><span class=\"line\">        // const result = arr.filter(function(item)&#123;</span><br><span class=\"line\">        //     if(item % 2 === 0)&#123;</span><br><span class=\"line\">        //         return true;</span><br><span class=\"line\">        //     &#125;else&#123;</span><br><span class=\"line\">        //         return false;</span><br><span class=\"line\">        //     &#125;</span><br><span class=\"line\">        // &#125;);</span><br><span class=\"line\">        </span><br><span class=\"line\">\t\t\t\t// 方法2： 使用箭头函数</span><br><span class=\"line\">        const result = arr.filter(item =&gt; item % 2 === 0);</span><br><span class=\"line\">        console.log(result);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 箭头函数适合与 this 无关的回调. 定时器, 数组的方法回调</span><br><span class=\"line\">        // 箭头函数不适合与 this 有关的回调.  事件回调, 对象的方法</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"6-rest参数\"><a href=\"#6-rest参数\" class=\"headerlink\" title=\"6.rest参数\"></a>6.rest参数</h1><p>ES6 引入 rest 参数，用于获取函数的实参，用来代替 arguments</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">* 作用与 arguments 类似</span><br><span class=\"line\">*/</span><br><span class=\"line\">function add(...args)&#123;</span><br><span class=\"line\"> console.log(args);  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">add(1,2,3,4,5);  //得到的是一个数组，可以使用数字的一些方法：filter、some、every、map</span><br><span class=\"line\">/**</span><br><span class=\"line\">* rest 参数必须是最后一个形参</span><br><span class=\"line\">*/</span><br><span class=\"line\">function minus(a,b,...args)&#123;</span><br><span class=\"line\"> console.log(a,b,args);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">minus(100,1,2,3,4,5,19);</span><br></pre></td></tr></table></figure>\n<p>**<strong>注意：rest 参数非常适合不定个数参数函数的场景</strong></p>\n<h1 id=\"7-spread-扩展运算符\"><a href=\"#7-spread-扩展运算符\" class=\"headerlink\" title=\"7.spread 扩展运算符\"></a>7.spread 扩展运算符</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const tfboys=[&#x27;AA&#x27;,&#x27;BB&#x27;,&#x27;CC&#x27;]</span><br><span class=\"line\">function chunwan()&#123;</span><br><span class=\"line\">    console.log(arguments);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">chunwan(...tfboys);  //0:&#x27;AA&#x27; 1:&#x27;BB&#x27; 2:&#x27;CC&#x27;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>rest 参数 和 spread区别：</p>\n</blockquote>\n<p><strong>rest 参数</strong> ： function add(…args) 是放在函数传参<br><strong>spread</strong>： fn(…tfboys) 是放在调用函数时</p>\n<blockquote>\n<p>应用<br>1.数组的合并</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const A = [&#x27;aa&#x27;,&#x27;bb&#x27;];</span><br><span class=\"line\">const B = [&#x27;cc&#x27;,&#x27;dd&#x27;];</span><br><span class=\"line\"></span><br><span class=\"line\">//方法1：</span><br><span class=\"line\">const C = A.concat(B)</span><br><span class=\"line\">console.log(C)   //[aa,bb,cc,dd]</span><br><span class=\"line\"></span><br><span class=\"line\">//方法2：（推荐）</span><br><span class=\"line\">const C = [...A,...B];</span><br><span class=\"line\">console.log(C)   //[aa,bb,cc,dd]</span><br></pre></td></tr></table></figure>\n\n<p>2.数组的克隆（浅拷贝）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const A = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;];</span><br><span class=\"line\">const B = [...A];</span><br><span class=\"line\">console.log(B)   //[a,b,c]</span><br></pre></td></tr></table></figure>\n<p>3.将伪数组转换为真正的数组</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const A = documents.querySelectorAll(&#x27;div&#x27;);</span><br><span class=\"line\">const B = [...A];</span><br><span class=\"line\">console.log(B) // [div,div,div]</span><br></pre></td></tr></table></figure>\n<h1 id=\"8-Symbol\"><a href=\"#8-Symbol\" class=\"headerlink\" title=\"8.Symbol\"></a>8.Symbol</h1><h2 id=\"8-1Symbol基本使用\"><a href=\"#8-1Symbol基本使用\" class=\"headerlink\" title=\"8.1Symbol基本使用\"></a>8.1Symbol基本使用</h2><p>ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是JavaScript 语言的第七种数据类型，是一种类似于字符串的数据类型。</p>\n<p>Symbol 特点:</p>\n<p>1.Symbol 的值是唯一的，用来解决命名冲突的问题<br>2.Symbol 值不能与其他数据进行运算<br>3.Symbol 定义 的 对象属 性 不能 使 用 for…in 循 环遍 历 ，但 是可 以 使 用Reflect.ownKeys 来获取对象的所有键名</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1. 创建</span><br><span class=\"line\">//创建 Symbol</span><br><span class=\"line\">let s1 = Symbol();</span><br><span class=\"line\">console.log(s1, typeof s1);  //内部实现唯一性，我们看不到</span><br><span class=\"line\"></span><br><span class=\"line\">//添加标识的 Symbol</span><br><span class=\"line\">let s2 = Symbol(&#x27;尚硅谷&#x27;);</span><br><span class=\"line\">let s2_2 = Symbol(&#x27;尚硅谷&#x27;);</span><br><span class=\"line\">console.log(s2 === s2_2);  //false</span><br><span class=\"line\"></span><br><span class=\"line\">//使用 Symbol for 定义</span><br><span class=\"line\">let s3 = Symbol.for(&#x27;尚硅谷&#x27;);</span><br><span class=\"line\">let s3_2 = Symbol.for(&#x27;尚硅谷&#x27;);</span><br><span class=\"line\">console.log(s3 === s3_2);  //true</span><br><span class=\"line\"></span><br><span class=\"line\">// 2. 不能与其他数据进行运算</span><br><span class=\"line\">let result = s + 100  //error</span><br><span class=\"line\">let result = s &gt; 100  //error</span><br><span class=\"line\">let result = s + s  //error</span><br><span class=\"line\">\t// 数据类型</span><br><span class=\"line\">\t// USONB you are so niubility</span><br><span class=\"line\">\tu undefined</span><br><span class=\"line\">\ts string symbol</span><br><span class=\"line\">\to object</span><br><span class=\"line\">\tn bull number</span><br><span class=\"line\">\tb boolean</span><br><span class=\"line\"></span><br><span class=\"line\">// 3.Symbol内置值</span><br><span class=\"line\">class Person &#123;</span><br><span class=\"line\">    static [Symbol.hasInstance](param)&#123;</span><br><span class=\"line\">        console.log(param);</span><br><span class=\"line\">        console.log(&quot;我被用来检测了&quot;)；</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let o = &#123;&#125;;</span><br><span class=\"line\">console.log(o instanceof Person); //我被用来检测了，false</span><br></pre></td></tr></table></figure>\n<p><strong>注: 遇到唯一性的场景时要想到 Symbol</strong></p>\n<h2 id=\"8-2应用\"><a href=\"#8-2应用\" class=\"headerlink\" title=\"8.2应用\"></a>8.2应用</h2><p>1.给对象添加方法方式一：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let game = &#123;</span><br><span class=\"line\">    name : &#x27;ran&#x27;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let methods = &#123;</span><br><span class=\"line\">    up:Symbol()</span><br><span class=\"line\">    down:Symbol()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">game[methods.up]=function()&#123;</span><br><span class=\"line\">    console.log(&#x27;aaa&#x27;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">game[methods.down]=function()&#123;</span><br><span class=\"line\">    console.log(&#x27;bbb&#x27;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(game)    // name: &#x27;ran&#x27;,Symbol(),Symbol()</span><br></pre></td></tr></table></figure>\n<p>2.方式二</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let youxi = &#123;</span><br><span class=\"line\">    name: &#x27;狼人杀&#x27;，</span><br><span class=\"line\">    [Symbol(&#x27;say&#x27;)]:function()&#123;</span><br><span class=\"line\">        console.log(&#x27;阿萨德&#x27;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(youxi)    // name:&#x27;狼人杀&#x27;,Symbol(say)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"9-promise\"><a href=\"#9-promise\" class=\"headerlink\" title=\"9.promise\"></a>9.promise</h1><p>Promise 主要解决回调地狱的问题，是 ES6 引入的异步编程的新解决方案。语法上 Promise 是一个构造函数，用来封装异步操作并可以获取其成功或失败的结果。</p>\n<p>Promise的三种状态：初始化，成功，失败<br>(1)Promise构造函数：Promise(executor){}</p>\n<p>(2）Promise.prototype.then方法</p>\n<p>(3）Promise.prototype.catch方法</p>\n<p>实例化promise时传入一个函数，有两个参数：resolve和reject</p>\n<p>调用resolve封装数据则代表成功，调用reject封装数据则代表失败</p>\n<p>实例化promise对象的then方法，可以传入两个函数，第一个对应resolve封装的数据，参数是value；第二个对应reject封装的数据，参数是reason</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//实例化 Promise</span><br><span class=\"line\">const p=new Promise(function (resolve, reject)&#123;</span><br><span class=\"line\">  setTimeout(function()&#123;</span><br><span class=\"line\">    let err=&#x27;数据读取失败&#x27;</span><br><span class=\"line\">    reject(err)</span><br><span class=\"line\">  &#125;,1000)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">//调用promise对象的then方法</span><br><span class=\"line\">p.then(function(value)&#123;</span><br><span class=\"line\">  console.log(value)</span><br><span class=\"line\">&#125;,function(reason)&#123;</span><br><span class=\"line\">  console.log(reason)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-2-promise读取文件\"><a href=\"#9-2-promise读取文件\" class=\"headerlink\" title=\"9.2 promise读取文件\"></a>9.2 promise读取文件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1.引入fs模块</span><br><span class=\"line\">const fs=require(&#x27;fs&#x27;)</span><br><span class=\"line\"> </span><br><span class=\"line\">//2.使用promise封装</span><br><span class=\"line\">const p=new Promise(function(resolve,reject)&#123;</span><br><span class=\"line\">    fs.readFile(&#x27;./study.txt&#x27;,(err,data)=&gt;&#123;</span><br><span class=\"line\">        if(err) reject(err)</span><br><span class=\"line\">        resolve(data)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"> </span><br><span class=\"line\">p.then(function(value)&#123;</span><br><span class=\"line\">    console.log(value.toString())</span><br><span class=\"line\">&#125;,function(reason)&#123;</span><br><span class=\"line\">    console.log(&#x27;读取失败&#x27;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"9-3-Promise封装AJAX操作\"><a href=\"#9-3-Promise封装AJAX操作\" class=\"headerlink\" title=\"9.3 Promise封装AJAX操作\"></a>9.3 Promise封装AJAX操作</h2><p>原生ajax：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1.创建对象</span><br><span class=\"line\">const xhr=new XMLHttpRequest()</span><br><span class=\"line\">//2.初始化</span><br><span class=\"line\">xhr.open(&#x27;GET&#x27;,&#x27;http://localhost:8080/getJoke&#x27;)</span><br><span class=\"line\">//3.发送</span><br><span class=\"line\">xhr.send()</span><br><span class=\"line\">//4.绑定事件，处理响应结果</span><br><span class=\"line\">xhr.onreadystatechange=function()&#123;</span><br><span class=\"line\">    if(xhr.readyState===4)&#123;</span><br><span class=\"line\">        if(xhr.status&gt;=200&amp;&amp;xhr.status&lt;300)&#123;</span><br><span class=\"line\">            console.log(xhr.response)</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            console.error(xhr.status)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>promise封装：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const p=new Promise(function(resolve, reject)&#123;</span><br><span class=\"line\">    const xhr=new XMLHttpRequest()</span><br><span class=\"line\">    xhr.open(&#x27;GET&#x27;,&#x27;http://localhost:8080/getJoke&#x27;)</span><br><span class=\"line\">    xhr.send()</span><br><span class=\"line\">    xhr.onreadystatechange=function()&#123;</span><br><span class=\"line\">        if(xhr.readyState===4)&#123;</span><br><span class=\"line\">            if(xhr.status&gt;=200&amp;&amp;xhr.status&lt;300)&#123;</span><br><span class=\"line\">                resolve(xhr.response)</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                reject(xhr.status)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">p.then(function(value)&#123;</span><br><span class=\"line\">    console.log(value)</span><br><span class=\"line\">&#125;,function(reason)&#123;</span><br><span class=\"line\">    console.log(reason)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-4-Promise-prototype-then-方法\"><a href=\"#9-4-Promise-prototype-then-方法\" class=\"headerlink\" title=\"9.4 Promise.prototype.then 方法\"></a>9.4 Promise.prototype.then 方法</h2><h1 id=\"10-class类\"><a href=\"#10-class类\" class=\"headerlink\" title=\"10.class类\"></a>10.class类</h1><h2 id=\"10-1特性\"><a href=\"#10-1特性\" class=\"headerlink\" title=\"10.1特性\"></a>10.1特性</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">\t//=================ES5========================</span><br><span class=\"line\">\t//手机</span><br><span class=\"line\">  function Phone(brand, price)&#123;</span><br><span class=\"line\">      this.brand = brand;</span><br><span class=\"line\">      this.price = price;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  //添加方法</span><br><span class=\"line\">  Phone.prototype.call = function()&#123;</span><br><span class=\"line\">      console.log(&quot;我可以打电话!!&quot;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  //实例化对象</span><br><span class=\"line\">  let Huawei = new Phone(&#x27;华为&#x27;, 5999);</span><br><span class=\"line\">  Huawei.call();</span><br><span class=\"line\">  console.log(Huawei);</span><br><span class=\"line\"></span><br><span class=\"line\">  //=================ES6========================</span><br><span class=\"line\">  class shouji &#123;</span><br><span class=\"line\">\t\t\t// constructor 这个名字不能修改，在进行new Phone时，自动执行</span><br><span class=\"line\">      constructor(brand,price) &#123;</span><br><span class=\"line\">          this.brand=brand;</span><br><span class=\"line\">          this.price=price</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t//对象方法，只能使用 方法名()&#123;&#125; 的写法，不能使用 方法名:function()&#123;&#125;</span><br><span class=\"line\">      call()&#123;</span><br><span class=\"line\">          console.log(&#x27;我可以打电话&#x27;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  let A = new shouji(&#x27;1+&#x27;,1999);</span><br><span class=\"line\">  console.log(A)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10-2静态成员\"><a href=\"#10-2静态成员\" class=\"headerlink\" title=\"10.2静态成员\"></a>10.2静态成员</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Phone()&#123;&#125;</span><br><span class=\"line\">Phone.name=&#x27;手机&#x27;</span><br><span class=\"line\">Phone.change=function()&#123;</span><br><span class=\"line\">    console.log(&#x27;我可以改变世界&#x27;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Phone.prototype.size=&#x27;5.5inch&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">let nokia=new Phone()//实例对象nokia</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(nokia.name);//undefind</span><br><span class=\"line\">nokia.change();</span><br><span class=\"line\">console.log(nokia.size)//5.5inch</span><br></pre></td></tr></table></figure>\n<p><strong>实例对象nokia，函数对象Phone</strong><br>实例对象和函数对象的属性不互通</p>\n<p>实例对象的属性和构造函数的<strong>原型对象</strong>(prototype)相通<br>添加属性或方法要添加在原型上（prototype），实例对象是通过原型链去找属性或方法的</p>\n<hr>\n<p>把属于类而不属于实例对象的属性称为静态成员</p>\n<p>即，对于static标注的属性，<strong>属于类而并不属于实例对象</strong><br>且声明的关键字即为static</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Phone&#123;</span><br><span class=\"line\">    static name =&#x27;手机&#x27;</span><br><span class=\"line\">    static change()&#123;</span><br><span class=\"line\">        console.log(&#x27;我可以改变世界&#x27;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let nokia=new Phone()</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(nokia.name)//undefind</span><br><span class=\"line\">console.log(Phone.name)//手机</span><br></pre></td></tr></table></figure>\n<h2 id=\"10-3-ES5使用构造函数实现继承\"><a href=\"#10-3-ES5使用构造函数实现继承\" class=\"headerlink\" title=\"10.3 ES5使用构造函数实现继承\"></a>10.3 ES5使用构造函数实现继承</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Phone(brand,price)&#123;</span><br><span class=\"line\">    this.brand=brand</span><br><span class=\"line\">    this.price=price</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Phone.prototype.call=function()&#123;</span><br><span class=\"line\">    console.log(&#x27;我可以打电话&#x27;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function SmartPhone(brand,price,color,size)&#123;</span><br><span class=\"line\">    Phone.call(this,brand,price)</span><br><span class=\"line\">    this.color=color</span><br><span class=\"line\">    this.size=size</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 设置子级构造函数的原型</span><br><span class=\"line\">SmartPhone.prototype=new Phone</span><br><span class=\"line\">SmartPhone.prototype.constructor=SmartPhone</span><br><span class=\"line\"> </span><br><span class=\"line\">// 声明子类的方法</span><br><span class=\"line\">SmartPhone.prototype.photo=function()&#123;</span><br><span class=\"line\">    console.log(&#x27;我可以拍照&#x27;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SmartPhone.prototype.playGame=function()&#123;</span><br><span class=\"line\">    console.log(&#x27;我可以玩游戏&#x27;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const cz=new SmartPhone(&#x27;锤子&#x27;,2499,&#x27;黑色&#x27;,&#x27;5.5inch&#x27;)</span><br><span class=\"line\">console.log(cz)</span><br></pre></td></tr></table></figure>\n<h2 id=\"10-4-class类继承\"><a href=\"#10-4-class类继承\" class=\"headerlink\" title=\"10.4 class类继承\"></a>10.4 class类继承</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Phone&#123;</span><br><span class=\"line\">    constructor(brand,price) &#123;</span><br><span class=\"line\">        this.brand=brand</span><br><span class=\"line\">        this.price=price</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    call()&#123;</span><br><span class=\"line\">        console.log(&#x27;我可以打电话&#x27;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">class SmartPhone extends Phone&#123;</span><br><span class=\"line\">    constructor(brand,price,color,size) &#123;</span><br><span class=\"line\">        super(brand,price);</span><br><span class=\"line\">        this.color=color</span><br><span class=\"line\">        this.size=size</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    photo()&#123;</span><br><span class=\"line\">        console.log(&#x27;拍照&#x27;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    playGame()&#123;</span><br><span class=\"line\">        console.log(&#x27;玩游戏&#x27;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const xm=new SmartPhone(&#x27;小米&#x27;,7799,&#x27;red&#x27;,&#x27;5.5inch&#x27;)</span><br><span class=\"line\">console.log(xm)</span><br><span class=\"line\">xm.call()</span><br></pre></td></tr></table></figure>\n<h2 id=\"10-5-子类对父类方法的重写\"><a href=\"#10-5-子类对父类方法的重写\" class=\"headerlink\" title=\"10.5 子类对父类方法的重写\"></a>10.5 子类对父类方法的重写</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class SmartPhone extends Phone&#123;</span><br><span class=\"line\">    constructor(brand,price,color,size) &#123;</span><br><span class=\"line\">        super(brand,price);</span><br><span class=\"line\">        this.color=color</span><br><span class=\"line\">        this.size=size</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    photo()&#123;</span><br><span class=\"line\">        console.log(&#x27;拍照&#x27;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    playGame()&#123;</span><br><span class=\"line\">        console.log(&#x27;玩游戏&#x27;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    call()&#123;</span><br><span class=\"line\">        console.log(&#x27;我可以进行视频通话&#x27;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"10-6-getter和setter的设置\"><a href=\"#10-6-getter和setter的设置\" class=\"headerlink\" title=\"10.6 getter和setter的设置\"></a>10.6 getter和setter的设置</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Phone&#123;</span><br><span class=\"line\">    get price()&#123;</span><br><span class=\"line\">        console.log(&#x27;价格属性被读取了&#x27;)</span><br><span class=\"line\">        return &#x27;naomukiyo&#x27;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    set price(newVal)&#123;</span><br><span class=\"line\">        console.log(&#x27;价格属性被修改了：&#x27;+newVal)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let s=new Phone()</span><br><span class=\"line\">console.log(s.price) //得到price的get方法返回值</span><br><span class=\"line\">s.price=&#x27;free&#x27;</span><br></pre></td></tr></table></figure>\n<h1 id=\"11-集合介绍与API\"><a href=\"#11-集合介绍与API\" class=\"headerlink\" title=\"11.集合介绍与API\"></a>11.集合介绍与API</h1><h2 id=\"11-1-Set\"><a href=\"#11-1-Set\" class=\"headerlink\" title=\"11.1 Set\"></a>11.1 Set</h2><p>ES6提供了新的数据结构Set（集合）。它类似于数组，但成员的值都是唯一的，集合实现了iterator接口，所以可以使用扩展运算符和for…of……进行遍历</p>\n<p>集合的属性和方法：</p>\n<p>1）size        返回集合的元素个数</p>\n<p>2）add        增加一个新元素，返回当前集合</p>\n<p>3）delete        删除元素，返回boolean值</p>\n<p>4）has        检测集合中是否包含某个元素，返回boolean值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//声明一个set</span><br><span class=\"line\">let s=new Set()</span><br><span class=\"line\">let s2=new Set([1,2,3,4,5,6])</span><br><span class=\"line\"> </span><br><span class=\"line\">// 元素个数</span><br><span class=\"line\">console.log(s2.size)</span><br><span class=\"line\">// 添加新的元素</span><br><span class=\"line\">s2.add(9)</span><br><span class=\"line\">// 删除元素</span><br><span class=\"line\">s2.delete(5)</span><br><span class=\"line\">// 检测</span><br><span class=\"line\">console.log(s2.has(4))</span><br><span class=\"line\">// 遍历</span><br><span class=\"line\">for(let v of s2)&#123;</span><br><span class=\"line\">    console.log(v)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 清空</span><br><span class=\"line\">s2.clear()</span><br></pre></td></tr></table></figure>\n<h2 id=\"11-2-集合实践\"><a href=\"#11-2-集合实践\" class=\"headerlink\" title=\"11.2 集合实践\"></a>11.2 集合实践</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr=[1,2,3,4,5,4,3,2,1]</span><br><span class=\"line\">// 1.数组去重</span><br><span class=\"line\">let result=[...new Set(arr)]</span><br><span class=\"line\">// 2.交集</span><br><span class=\"line\">let arr2=[4,5,6,5,4]</span><br><span class=\"line\">let r2=[...new Set(arr)].filter(item=&gt;&#123;</span><br><span class=\"line\">    let s2=new Set(arr2)</span><br><span class=\"line\">    return s2.has(item)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// 3.并集</span><br><span class=\"line\">let union=[...new Set([...arr,...arr2])]</span><br><span class=\"line\">// 4.差集</span><br><span class=\"line\">let diff=[...new Set(arr)].filter(item=&gt;</span><br><span class=\"line\">    !new Set(arr2).has(item)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h2 id=\"11-3-Map\"><a href=\"#11-3-Map\" class=\"headerlink\" title=\"11.3 Map\"></a>11.3 Map</h2><p>ES6提供了Map数据结构。它类似于对象，也是键值对的集合。但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当键。Map可以使用扩展运算符和for…of…进行遍历</p>\n<p>Map的属性和方法：</p>\n<p>1）size        返回Map的元素个数</p>\n<p>2）set        增加一个新元素，返回当前Map</p>\n<p>3）get        返回键名对象的键值</p>\n<p>4）has        检测Map中是否包含某个元素，返回boolean值</p>\n<p>5）clear        清空集合，返回undefined</p>\n<p>6）delete        根据键删除键值对</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 声明Map</span><br><span class=\"line\">let m=new Map()</span><br><span class=\"line\"> </span><br><span class=\"line\">// 添加元素</span><br><span class=\"line\">m.set(&#x27;name&#x27;,&#x27;尚硅谷&#x27;)</span><br><span class=\"line\">m.set(&#x27;change&#x27;,function()&#123;</span><br><span class=\"line\">    console.log(&#x27;我们可以改变你&#x27;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let key=&#123;</span><br><span class=\"line\">    school:&#x27;ATGUIGU&#x27;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">m.set(key,[&#x27;北京&#x27;,&#x27;上海&#x27;,&#x27;深圳&#x27;])</span><br><span class=\"line\">//size</span><br><span class=\"line\">console.log(m.size)</span><br><span class=\"line\">//删除</span><br><span class=\"line\">m.delete(&#x27;name&#x27;)</span><br><span class=\"line\">//获取</span><br><span class=\"line\">console.log(m.get(&#x27;change&#x27;))</span><br><span class=\"line\">//遍历</span><br><span class=\"line\">for(let v of m)&#123;</span><br><span class=\"line\">    console.log(v)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","text":"一.入门const和let是在ES6中引入的两个新的变量声明关键字，用于声明变量的作用域.1.const let var1.1 const：(1)一定要赋初始值1<br>const A; //error<br>(2)一般常量使用大写（潜规则）<br>(3)常量的值不能修改<br>","raw":null,"photos":[],"categories":[],"tags":[]}]}
{"title":"","slug":"【ts】","date":"2025-01-19T11:50:13.178Z","updated":"2025-01-19T11:49:42.787Z","comments":true,"path":"api/articles/【ts】.json","photos":[],"excerpt":null,"covers":null,"content":"<p>TypeScript (简称 TS) 和 JavaScript (简称 JS) 都是用于编写Web应用程序的语言，它们的区别在于：</p>\n<h1 id=\"1-类型不同\"><a href=\"#1-类型不同\" class=\"headerlink\" title=\"1.类型不同\"></a>1.类型不同</h1><p>JS:一种脚本语言，用于创建动态网页，弱类型，没有静态类型选项</p>\n<p>TS：ts是js的超集，用于解决大项项目的代码复杂性，强类型，支持静态和动态类型；ts包含了js的库和函数，ts上可以写任何的js，调用任何的js库，可以在ts中使用原生js语法</p>\n<h1 id=\"2-数据类型不同\"><a href=\"#2-数据类型不同\" class=\"headerlink\" title=\"2.数据类型不同\"></a>2.数据类型不同</h1><p>TS的数据类型有：布尔值、数字、字符串、数组、 元组（tuple）、枚举(enum)、any、void、<br>null和undefined、never、object ，unknown，</p>\n<blockquote>\n<p>基本数据类型有boolean、number 、string 、 array 、 enum 、any 、void。</p>\n</blockquote>\n<p>定义一个boolean的变量:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var isDone: boolean = false;</span><br></pre></td></tr></table></figure>\n<p>JS与TS中的所有数值都是浮点型，而在TS中定义为“number”型。声明一个number类型的变量：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var isNumber:number=6;</span><br><span class=\"line\">var isfloat:number=6.01;</span><br></pre></td></tr></table></figure>\n<p>使用一对双引号(“)或一对单引号(‘)来表示字符串</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name: string = &quot;bob&quot;;</span><br><span class=\"line\">var family_name: string = &#x27;Green&#x27;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>TypeScript 中<strong>数组</strong>使用“[]”来声明，代码如下:</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> var list: number[] = [1, 2, 3];</span><br><span class=\"line\">var name: string[] = [&quot;阿龙&quot;,&quot;阿猫&quot;,&quot;阿狗&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">// 访问方式 </span><br><span class=\"line\">var list: number[] = [1, 2, 3];</span><br><span class=\"line\">alert(list[0]));</span><br><span class=\"line\"></span><br><span class=\"line\">// 定义任意类型的数组，关键字为Array.</span><br><span class=\"line\">var arr:Array = [1,2,3,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]; // 任意类型数组</span><br><span class=\"line\">alert(arr[1]);</span><br></pre></td></tr></table></figure>\n<h2 id=\"enum\"><a href=\"#enum\" class=\"headerlink\" title=\"enum\"></a>enum</h2><p>ts新加的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Color &#123;</span><br><span class=\"line\">  Red,　　　//枚举元素列表</span><br><span class=\"line\">  Green,</span><br><span class=\"line\">  Blue</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var c: Color = Color.Green;</span><br></pre></td></tr></table></figure>\n<p>假如我们有一个数值，但是我们不知道枚举类型中是否有定义，可以用以下方式来获取，代码如下:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Color &#123;</span><br><span class=\"line\">  Red = 1,</span><br><span class=\"line\">  Green,</span><br><span class=\"line\">  Blue</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var colorName: string = Color[2]; //访问第二个枚举子元素Green</span><br><span class=\"line\">alert(colorName);</span><br><span class=\"line\">colorName = Color[4];</span><br><span class=\"line\">alert(colorName);</span><br></pre></td></tr></table></figure>\n<p>那么将会输出Green和undefined。因为Green的值是 2，而没有一个枚举定义的值是 4，所以返回undefined。</p>\n<h2 id=\"任意类型-any\"><a href=\"#任意类型-any\" class=\"headerlink\" title=\"任意类型 any\"></a>任意类型 any</h2><p>和js一样，指代是动态的，能够赋予任意类型</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var notSure: any = 4;</span><br><span class=\"line\">notSure = &quot;maybe a string instead&quot;;</span><br><span class=\"line\">notSure = false;  // 定义为boolen型</span><br></pre></td></tr></table></figure>\n<p>any可以配合数组来使用，代码如下:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var list: any[] = [1, true, &quot;free&quot;];</span><br><span class=\"line\">list[1] = 100; //更改list[1]的值</span><br></pre></td></tr></table></figure>\n<p>注意，不要滥用 any，如果任何值都指定为 any 类型，那么ts将失去它的意义</p>\n<h2 id=\"void\"><a href=\"#void\" class=\"headerlink\" title=\"void\"></a>void</h2><p>void 和 any 相反，any 是表示任意类型，而 void 是表示没有任意类型，就是什么类型都不是，这在我们定义函数，函数没有返回值时会用到：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const consoleText = (text: string): void =&gt; &#123;</span><br><span class=\"line\">  console.log(text);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>void 类型的变量只能赋值为 undefined 和 null，其他类型不能赋值给 void 类型的变量。</p>\n<h2 id=\"never\"><a href=\"#never\" class=\"headerlink\" title=\"never\"></a>never</h2><p>never 类型指那些永不存在的值的类型，它是那些总会抛出异常或根本不会有返回值的函数表达式的返回值类型，当变量被永不为真的类型保护所约束时，该变量也是 never 类型。<br>例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const errorFunc = (message: string): never =&gt; &#123;</span><br><span class=\"line\">  throw new Error(message);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这个 errorFunc 函数总是会抛出异常，所以它的返回值类型是 never，用来表明它的返回值是永不存在的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const infiniteFunc = (): never =&gt; &#123;</span><br><span class=\"line\">  while (true) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<ul>\n<li><p>never：never 是其它类型（包括 null 和 undefined）的子类型，代表从不会出现的值；<br>​</p>\n<blockquote>\n<p>any 和unknown的区别<br>相同： 都可以赋任意类型的值，最终该变量的类型 由最后一个值的类型决定<br>不同： any可以赋值给任意类型的变量，并将该变量的类型修改为any变量值的类型<br>    unknown 不可以<br>    可以把unknown 看做是安全的any</p>\n</blockquote>\n<pre><code>如果非要把unknown 赋值给其他类型 怎么办？\n  使用类型断言、或类型判断（通过if typeof ）\n  类型断言： 变量 as 类型 表示 告诉ts 该变量的实际类型\n</code></pre>\n</li>\n</ul>\n<p>JS的数据类型有：string,number,boolean,null,undefined,object,array,function,symbol(es6中引入)</p>\n<h1 id=\"3-类型声明\"><a href=\"#3-类型声明\" class=\"headerlink\" title=\"3.类型声明\"></a>3.类型声明</h1><p>TS中的类型声明：指定类型后，当变量赋值时，TS编译器就会自动检查值是否符合声明类型，如果符合就赋值，不符合就报错</p>\n<p>JS中的类型声明：变量类型声明并不是强制性的，因为 JavaScript 是一种动态类型语言，变量的类型会在运行时自动确定</p>\n<h1 id=\"4-编译\"><a href=\"#4-编译\" class=\"headerlink\" title=\"4.编译\"></a>4.编译</h1><p>TS需要将代码编译为js代码才能在浏览器中执行</p>\n<p>JS可以直接在浏览器中运行</p>\n<h1 id=\"5-ts的类\"><a href=\"#5-ts的类\" class=\"headerlink\" title=\"5.ts的类\"></a>5.ts的类</h1><h2 id=\"5-1-类的结构\"><a href=\"#5-1-类的结构\" class=\"headerlink\" title=\"5.1 类的结构\"></a>5.1 类的结构</h2><p>创建一个TypeScript类时，必须使用关键字class进行声明，该关键字后紧跟类的名称，之后用大括号将类体进行封装，类的基本声明格式如下。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class 类名&#123;</span><br><span class=\"line\">    //类体</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建完成类的基本结构后就可以编写类体。类体中主要包括属性和方法的声明及定义，当然也可能在类体中只定义属性或只定义方法，甚至类体内可以不定义任何属性。完整的类的定义格式如下。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class 类名&#123;</span><br><span class=\"line\">  name:string;  //定义类的属性</span><br><span class=\"line\">  fun()&#123; //定义类的方法</span><br><span class=\"line\">           //定义该方法所要实现的功能</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>为什么可以不定义任何属性？<br> 类可以被继承，它的方法和属性可以在子类中被继承<br> 未定义任何方法的空类可以作为泛型类<br> 综上未定义任何方法的空类其名称具有价值</li>\n<li>构造函数</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class student&#123;  //定义student类</span><br><span class=\"line\">  name:string;  //定义类的属性</span><br><span class=\"line\">  constructor(myname:string)&#123; //定义构造函数</span><br><span class=\"line\">      this.name=myname;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  study()&#123; //定义类的方法</span><br><span class=\"line\">           //定义该方法所要实现的功能</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-2-类的实例化\"><a href=\"#5-2-类的实例化\" class=\"headerlink\" title=\"5.2 类的实例化\"></a>5.2 类的实例化</h2><p>一般情况下，创建一个类后并不能直接的对属性和方法进行引用，必须对类进行实例化，即创建一个对象。TypeScript中用new 关键字创建对象。实例化后通过“.”来访问属性和方法。实例代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class student&#123;  //定义student类</span><br><span class=\"line\">  name:string;  //定义类的属性</span><br><span class=\"line\">  constructor(myname:string)&#123; //定义带参数的构造函数</span><br><span class=\"line\">      this.name=myname;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">   study()&#123; //定义类的方法</span><br><span class=\"line\">      document.write(&quot;&lt;h1&gt; My name is &quot;+this.name+&quot;.&lt;/h1&gt;&quot;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">   write():string&#123;</span><br><span class=\"line\">           return &quot;write name:&quot;+this.name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>类的使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s1=new student(&quot;Jim&quot;);</span><br><span class=\"line\">document.write(&quot;&lt;h1&gt;&quot;+s1.name+&quot;&lt;/h1&gt;&quot;); //获取name属性</span><br><span class=\"line\">s1.study();   // 调用study方法  </span><br><span class=\"line\">document.write(&quot;&lt;h1&gt;&quot;+s1.write()+&quot;&lt;/h1&gt;&quot;);</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"6-函数的不同：\"><a href=\"#6-函数的不同：\" class=\"headerlink\" title=\"6.函数的不同：\"></a>6.函数的不同：</h1><p>（1）TS：需要对函数中形参进行<strong>类型声明</strong></p>\n<p>JS中函数定义参数，传参的时候，可以传递任意类型，不够严谨</p>\n<p>（2）js中当函数没有返回值的时候 默认返回值是undefined</p>\n<p>TS: 第一种情况：不设置返回值类型，但是有返回值,这个时候TS解析器会根据返回值的类型进行判断，返回值类型是什么 函数返回值类型就是什么</p>\n<p>第二种情况：设置返回值类型，则return的值必须严格按照返回值类型进行返回</p>\n<p>第三种情况：设置返回值类型为void，<br>void:用来表示空，以函数为例，就表示没有返回值的函数,或者说 返回值为空 ，<br>如果想要一点返回值都没有，设置返回值类型为never（永远不会返回结果）</p>\n<h2 id=\"ts函数的定义与调用\"><a href=\"#ts函数的定义与调用\" class=\"headerlink\" title=\"ts函数的定义与调用\"></a>ts函数的定义与调用</h2><p>定义函数的语法为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function function_name(arg:number,arg1:number,....):return_type&#123;</span><br><span class=\"line\">  code 函数要执行的代码;</span><br><span class=\"line\">  return data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>_returntype为该函数的返回值类型</strong> ,function 为声明函数的关键字，function_name 为自定义函数的名字</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function add(x: number, y: number): number &#123;  //定义返回值为number类型的函数</span><br><span class=\"line\">    return x+y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">add(5,6); //调用函数</span><br></pre></td></tr></table></figure>\n<ul>\n<li>匿名函数<br> 匿名函数是没有名称只有主体的函数，不需要指定返回类型，它的返回值类型是从函数主体内的 return 语句推断的。如下代码：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myAdd = function(x:number, y:number) &#123; //定义匿名函数</span><br><span class=\"line\">  return x+y;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">myAdd(3,4); //调用匿名函数</span><br></pre></td></tr></table></figure>\n<ul>\n<li>可选与默认参数<br>可选参数：在参数名后面，冒号前面添加一个问号，则表明该参数是可选的。如下代码：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function buildName(firstName: string, lastName?: string) &#123; //lastName为可选参数</span><br><span class=\"line\">  if (lastName)</span><br><span class=\"line\">      return firstName + &quot; &quot; + lastName;</span><br><span class=\"line\">  else</span><br><span class=\"line\">      return firstName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var result1 = buildName(&quot;Bob&quot;);  //正确调用 Bob</span><br><span class=\"line\">var result2 = buildName(&quot;Bob&quot;, &quot;Adams&quot;); //正确调用 Bob Adams</span><br></pre></td></tr></table></figure>\n<p>默认参数：在参数名后直接给定一个值，如果这个值没有被传入，那么将会被赋值为默认值。如下代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function buildName(firstName: string, lastName = &quot;Smith&quot;) &#123;</span><br><span class=\"line\">  return firstName + &quot; &quot; + lastName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var result1 = buildName(&quot;Bob&quot;);  //没有传入第二个参数，则被赋值为默认的smith,结果为:Bob Smith</span><br><span class=\"line\">var result2 = buildName(&quot;Bob&quot;, &quot;Adams&quot;);  //结果为:Bob Adams</span><br></pre></td></tr></table></figure>\n<p>注：<strong>可选参数和默认参数必须在参数列表的最后。</strong></p>\n<h1 id=\"7-数组类型声明：\"><a href=\"#7-数组类型声明：\" class=\"headerlink\" title=\"7.数组类型声明：\"></a>7.数组类型声明：</h1><p>js中，数组的元素，可以是任意类型，没有局限性</p>\n<p>TS中,对数组类型声明之后就只能存放一种数据类型的数据，假如想创建一个能存储任意类型的数组</p>\n<blockquote>\n<p>let e:Array<any> &#x2F; let e:any[];</p>\n</blockquote>\n<ul>\n<li>第一种：</li>\n</ul>\n<blockquote>\n<p>let 变量名:类型名[];</p>\n</blockquote>\n<ul>\n<li>第二种：</li>\n</ul>\n<blockquote>\n<p>let 变量名:Array&lt;类型名&gt;;</p>\n</blockquote>\n<h1 id=\"8-TS中的枚举和JS中的对象不一样\"><a href=\"#8-TS中的枚举和JS中的对象不一样\" class=\"headerlink\" title=\"8.TS中的枚举和JS中的对象不一样\"></a>8.TS中的枚举和JS中的对象不一样</h1><p>枚举代表的是一系列特定类型的对象 这是从别的编程语言派生出来的概念，所以我们不能用 js 的概念强加到它上面，其实枚举最好理解的就是一系列确定的常量。枚举中的属性，只能用来取值，不能重新赋值 [只读属性]</p>\n<h1 id=\"9-创建对象的方式：\"><a href=\"#9-创建对象的方式：\" class=\"headerlink\" title=\"9.创建对象的方式：\"></a>9.创建对象的方式：</h1><p>JS的创建对象的方式：1.基于Object的方式创建对象，2.对象字面量，3.构造函数，4.原型prototype，5.class 类</p>\n<p>TS的创建对象的方式：1、通过字面量 2、通过0bject 3、通过工厂模式创建 4、通过构造函数创建 5、通过class类创建 6、可以通过实现接口创建 7、通过继承抽象类创建</p>\n<h1 id=\"10-ts接口与类\"><a href=\"#10-ts接口与类\" class=\"headerlink\" title=\"10.ts接口与类\"></a>10.ts接口与类</h1><h2 id=\"10-1-定义和用途\"><a href=\"#10-1-定义和用途\" class=\"headerlink\" title=\"10.1. 定义和用途\"></a>10.1. 定义和用途</h2><ul>\n<li><p>接口：<strong>用于限制对象的具体属性</strong><br>用于定义对象的结构和类型，包括属性和方法的名称及其类型。接口提供了一种协议，确保实现它的对象遵循特定的形态。它不包含任何实现细节。</p>\n</li>\n<li><p>类：用于创建对象的蓝图，包括属性和方法的实现。类可以包含构造函数、访问修饰符（如 public、private）、静态方法等，允许创建对象的实例。</p>\n</li>\n</ul>\n<h2 id=\"10-2-实现\"><a href=\"#10-2-实现\" class=\"headerlink\" title=\"10.2.实现\"></a>10.2.实现</h2><p>接口：接口可以被类实现（使用 implements 关键字），一个类可以实现多个接口，达到多重继承的效果。</p>\n<p>类：类可以继承其他类（使用 extends 关键字），该过程中可以重用父类的实现和属性。但一个类只能继承一个父类，这被称为单继承。</p>\n<h2 id=\"10-3可以包含的内容\"><a href=\"#10-3可以包含的内容\" class=\"headerlink\" title=\"10.3可以包含的内容\"></a>10.3可以包含的内容</h2><ul>\n<li><p>接口：只能定义属性和方法的签名，不能包含具体的实现。接口可以扩展其他接口。</p>\n</li>\n<li><p>类：可以包含完整的方法实现、构造函数、字段、修饰符等。</p>\n</li>\n</ul>\n<h2 id=\"10-4-实例化\"><a href=\"#10-4-实例化\" class=\"headerlink\" title=\"10.4 实例化\"></a>10.4 实例化</h2><blockquote>\n<ul>\n<li>接口：不能被实例化。接口只是定义的一个约束，不能用作对象的实例。</li>\n<li>类：可以被实例化。类可以通过 new 操作符创建对象的实例。</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> // 定义接口  </span><br><span class=\"line\">interface Animal &#123;  </span><br><span class=\"line\">    name: string;  </span><br><span class=\"line\">    sound(): string;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"> </span><br><span class=\"line\">// 实现接口的类  </span><br><span class=\"line\">class Dog implements Animal &#123;  </span><br><span class=\"line\">    name: string;  </span><br><span class=\"line\"> </span><br><span class=\"line\">    constructor(name: string) &#123;  </span><br><span class=\"line\">        this.name = name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"> </span><br><span class=\"line\">    sound(): string &#123;  </span><br><span class=\"line\">        return &quot;Bark&quot;;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"> </span><br><span class=\"line\">// 实例化类  </span><br><span class=\"line\">const myDog = new Dog(&quot;Buddy&quot;);  </span><br><span class=\"line\">console.log(myDog.name); // 输出：Buddy  </span><br><span class=\"line\">console.log(myDog.sound()); // 输出：Bark</span><br></pre></td></tr></table></figure>\n<p>在这个示例中，Animal 是一个接口，定义了 name 属性和 sound 方法。Dog 是一个实现了 Animal 接口的类，具体实现了 sound 方法。最后，我们用 new 关键字创建了 Dog 的实例</p>\n</blockquote>\n<ul>\n<li>接口用来申明方法</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Animal &#123;   // 动物接口</span><br><span class=\"line\">    eat() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Sheep implements Animal &#123; // implements声明sheep类实现Animal接口</span><br><span class=\"line\">    // 当一个类实现一个接口时必须实现接口中声明的方法,否则报错</span><br><span class=\"line\">    eat() &#123;</span><br><span class=\"line\">        console.log(&#x27;sheep实现animal接口&#x27;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>当一个类实现一个接口时必须实现接口中声明的方法</strong></p>\n<h1 id=\"11-泛型\"><a href=\"#11-泛型\" class=\"headerlink\" title=\"11.泛型\"></a>11.泛型</h1><p>JavaScript是一种基于原型的语言，而不是传统的面向对象语言，不支持模块，不支持泛型或接口</p>\n<p>TypeScript在JavaScript的基础上添加了类、接口、继承、泛型等面向对象编程的概念和特性，它允许模块化编程，可以把声明、数据、函数和类封装在模块中。使得代码组织和维护更加容易</p>\n<ul>\n<li>概述：<br>参数化的类型，一般用来限制集合的内容</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var workers: Array&lt;Person&gt; = [];</span><br><span class=\"line\">// 尖括号中的Person类型就是这个数组的泛型，规定了数组中只能放Person类型</span><br><span class=\"line\">workers[0] = new Person(&#x27;zhangsan&#x27;);</span><br><span class=\"line\">workers[1] = new Person(&#x27;lisi&#x27;);  </span><br><span class=\"line\">workers[2] = 1;  // 报错</span><br></pre></td></tr></table></figure>\n<ul>\n<li>模块<br>模块将代码分割成可重用的单元，开发者可以自行决定将模块中的哪些资源（类、方法、变量）暴露出去供外部使用，哪些资源只在模块内部使用。</li>\n</ul>\n<ul>\n<li>export: 对外暴露</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// a.ts</span><br><span class=\"line\">export var prop1;   // 对外暴露prop1属性</span><br><span class=\"line\">var prop2;  // 不对外暴露</span><br><span class=\"line\"></span><br><span class=\"line\">export function func1() &#123;&#125;  // 对外暴露func1方法</span><br><span class=\"line\">function func2() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export class Clazz1 &#123;&#125;</span><br><span class=\"line\">class Clazz2 &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// b.ts</span><br><span class=\"line\">import &#123;prop1, func1&#125; from &#x27;./a&#x27;;</span><br><span class=\"line\">console.log(prop1);</span><br><span class=\"line\">func1();      // 调用a.ts模块中对外暴露的方法</span><br></pre></td></tr></table></figure>\n<h1 id=\"12-ts模块\"><a href=\"#12-ts模块\" class=\"headerlink\" title=\"12.ts模块\"></a>12.ts模块</h1><p>我们先举个例子，比如数据验证，我们需要验证用户数字的内容是否是数字或者字母时，需要使用正则表达式。</p>\n<p>var lettersRegexp &#x3D; &#x2F; ^ [A-Za-z]+$&#x2F;;</p>\n<p>var numberRegexp &#x3D; &#x2F; ^ [0-9]+$&#x2F;;</p>\n<p>使用 module 关键字来定义模块，并在末尾加花括号即可用；<br> 用export 关键字使接口、类等成员对模块外可见。<br> <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> module Validation &#123;   //定义模块</span><br><span class=\"line\">  export interface StringValidator &#123;  //声明接口对外部可以使用</span><br><span class=\"line\">    isAcceptable(s: string): boolean;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  var lettersRegexp = /^[A-Za-z]+$/;</span><br><span class=\"line\">  var numberRegexp = /^[0-9]+$/;</span><br><span class=\"line\"></span><br><span class=\"line\">  export class LettersOnlyValidator implements StringValidator &#123;  //声明类对外部可用</span><br><span class=\"line\">    isAcceptable(s: string) &#123;</span><br><span class=\"line\">      return lettersRegexp.test(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  export class ZipCodeValidator implements StringValidator &#123;</span><br><span class=\"line\">    isAcceptable(s: string) &#123;</span><br><span class=\"line\">      return s.length === 5 &amp;&amp; numberRegexp.test(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"12-1-模块内容的调用\"><a href=\"#12-1-模块内容的调用\" class=\"headerlink\" title=\"12.1 模块内容的调用\"></a>12.1 模块内容的调用</h2><p>在前面一节中我学习了模块的声明，而在模块声明完成以后，我们就可以调用这个模块了，调用模块中的接口、类、方法等。调用方法简单，就是用模块名后面跟一个点来调用类、接口、方法等。如下代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">var strings = [&#x27;Hello&#x27;, &#x27;98052&#x27;, &#x27;101&#x27;];</span><br><span class=\"line\">var validators: &#123; [s: string]: Validation.StringValidator; &#125; = &#123;&#125;;</span><br><span class=\"line\">validators[&#x27;ZIP code&#x27;] = new Validation.ZipCodeValidator();  //使用模块中的类</span><br><span class=\"line\">validators[&#x27;Letters only&#x27;] = new Validation.LettersOnlyValidator();</span><br><span class=\"line\">// 显示匹配结果</span><br><span class=\"line\">for(var i=0;i&amp;ltstrings.length;i++)&#123;</span><br><span class=\"line\">  for (var name in validators) &#123;</span><br><span class=\"line\">     document.write(&#x27;&quot;&#x27; + strings[i] + &#x27;&quot; &#x27; + (validators[name].isAcceptable(strings[i]) ? &#x27; matches &#x27; : &#x27; does not match &#x27;) + name+&quot;&lt;br&gt;&quot;); // 使用方法</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"12-2分隔模块到多个文件\"><a href=\"#12-2分隔模块到多个文件\" class=\"headerlink\" title=\"12.2分隔模块到多个文件\"></a>12.2分隔模块到多个文件</h2><p>随着我们项目的扩展，我们的代码总不可能只写在一个文件里。为了更好地维护项目，我们会将特定功能放到一个文件里，然后加载多个文件实现我们想需要的功能。现在我们先将上面的代码分割到多个文件里。</p>\n<ul>\n<li>文件一    Validation.ts</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module Validation &#123;</span><br><span class=\"line\">  export interface StringValidator &#123;</span><br><span class=\"line\">      isAcceptable(s: string): boolean;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>文件二   LettersOnlyValidator.ts</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;</span><br><span class=\"line\">module Validation &#123;</span><br><span class=\"line\">  var lettersRegexp = /^[A-Za-z]+$/;</span><br><span class=\"line\">  export class LettersOnlyValidator implements StringValidator &#123;</span><br><span class=\"line\">      isAcceptable(s: string) &#123;</span><br><span class=\"line\">        return lettersRegexp.test(s);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>文件三    ZipCodeValidator.ts</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;</span><br><span class=\"line\">module Validation &#123;</span><br><span class=\"line\">  var numberRegexp = /^[0-9]+$/;</span><br><span class=\"line\">  export class ZipCodeValidator implements StringValidator &#123;</span><br><span class=\"line\">    isAcceptable(s: string) &#123;</span><br><span class=\"line\">      return s.length === 5 &amp;&amp; numberRegexp.test(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>文件四 Test.ts</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;</span><br><span class=\"line\">/// &lt;reference path=&quot;LettersOnlyValidator.ts&quot; /&gt;</span><br><span class=\"line\">/// &lt;reference path=&quot;ZipCodeValidator.ts&quot; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">var strings = [&#x27;Hello&#x27;, &#x27;98052&#x27;, &#x27;101&#x27;];</span><br><span class=\"line\">var validators: &#123; [s: string]: Validation.StringValidator; &#125; = &#123;&#125;;</span><br><span class=\"line\">validators[&#x27;ZIP code&#x27;] = new Validation.ZipCodeValidator();</span><br><span class=\"line\">validators[&#x27;Letters only&#x27;] = new Validation.LettersOnlyValidator();</span><br><span class=\"line\">for(var i=0;i&amp;ltstrings.length;i++)&#123;</span><br><span class=\"line\">  for (var name in validators) &#123;</span><br><span class=\"line\">     document.write(&#x27;&quot;&#x27; + strings[i] + &#x27;&quot; &#x27; + (validators[name].isAcceptable(strings[i]) ? &#x27; matches &#x27; : &#x27; does not match &#x27;) + name+&quot;&lt;br&gt;&quot;); //调用类的方法</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在项目中新建好以上四个文件，然后我们编译项目，如果我们代码编写没错的话，是能够编译通过的。</p>\n<blockquote>\n<p>我们可以见到后面三个文件开头的文档注释，</p>\n<blockquote>\n<p>&#x2F;&#x2F;&#x2F; &lt; reference path&#x3D;“Validation.ts” &#x2F;&gt;<br>&#x2F;&#x2F;&#x2F; &lt; reference path&#x3D;“LettersOnlyValidator.ts” &#x2F;&gt;<br>&#x2F;&#x2F;&#x2F; &lt; reference path&#x3D;“ZipCodeValidator.ts” &#x2F;&gt;</p>\n<blockquote>\n<blockquote>\n<p>这是告诉 TypeScript 编译器该文件依赖于哪些文件，假如依赖的文件不存在的话，编译就会不通过。当然我们不写也是可以的，只不过编译器在编译时不会帮我们检查，一般来说，还是建议写上。</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<h2 id=\"12-3-TS的编译\"><a href=\"#12-3-TS的编译\" class=\"headerlink\" title=\"12.3 TS的编译\"></a>12.3 TS的编译</h2><p>我们知道.js的文件可以直接在浏览器中运行的，而.ts或者.tsx却不行，所以我们在运行TS项目时需要编译成浏览器引擎可以识别的JS语言。同时为了提高编译速度，我们可以将稳定的module提前编译成js文件放到工程中，这样下次编译就会直接跳过该nodule的编译。在引用编译生成的 JavaScript 文件时，我们需要注意好顺序。以上面的代码为例，我们在 Html 代码中这么引用。</p>\n<h1 id=\"13-继承\"><a href=\"#13-继承\" class=\"headerlink\" title=\"13.继承\"></a>13.继承</h1><p>TypeScript 支持类的继承，可以通过 extends 关键字指定一个类继承自另一个类。</p>\n<p>而在 JavaScript 中，除了es6，其他的语法规范，不支持使用extends来继承。</p>\n<h1 id=\"13-访问修饰符\"><a href=\"#13-访问修饰符\" class=\"headerlink\" title=\"13.访问修饰符\"></a>13.访问修饰符</h1><p>TypeScript 引入了额外的访问修饰符（如 public、private 和 protected）来控制类的成员的访问范围。这增加了对类及其成员的访问权限控制。而在 JavaScript 中，类和类成员的访问权限是公共的。</p>\n<h1 id=\"14-可选的构造函数参数\"><a href=\"#14-可选的构造函数参数\" class=\"headerlink\" title=\"14.可选的构造函数参数\"></a>14.可选的构造函数参数</h1><p>在 TypeScript 中，我们可以在构造函数参数上使用 ? 表示可选参数。这使得我们可以定义构造函数参数的可选性。而在 JavaScript 中，构造函数参数是必需的。</p>\n<h1 id=\"15-重载\"><a href=\"#15-重载\" class=\"headerlink\" title=\"15.重载\"></a>15.重载</h1><p>js没有重载概念</p>\n<p>ts有可以重载：重载指的是在同一个类中定义多个同名的方法，但它们的参数类型、参数个数或返回类型不同。通过重载，我们可以为同一个方法名创建多个具有不同参数的版本。</p>\n<h1 id=\"16-重写\"><a href=\"#16-重写\" class=\"headerlink\" title=\"16.重写\"></a>16.重写</h1><p>ts增加了重写，子类覆盖了父类中的属性或者是方法叫做重写 子类和父类同名的方法和属性，在子类中重新声明的时候，就覆盖了父类原本的内容）</p>\n<h1 id=\"17-static和readonly\"><a href=\"#17-static和readonly\" class=\"headerlink\" title=\"17.static和readonly\"></a>17.static和readonly</h1><p>ts中增加了static和readonly，而js中没有</p>\n<p>static</p>\n<p>（静态修饰符，被static修饰的属性或者是方法，属于类的。可以通过类名调用，不属于实例的，实例没办使用 和es6中的static一样）</p>\n<p>readonly<br>（被readonly修饰的属性，只能读取不能修改）</p>\n","categories":[],"tags":[]}